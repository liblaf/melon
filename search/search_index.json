{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Explore the docs \u00bb</p> <p> </p> <p>Changelog \u00b7 Report Bug \u00b7 Request Feature</p> <p></p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83d\uddc2\ufe0f Advanced I/O: Supports reading and writing various mesh formats (OBJ, PLY, STL, VTK, VTP, VTU) with seamless integration to PyVista and Trimesh;</li> <li>\ud83d\udccd Proximity Analysis: Provides efficient algorithms for nearest point and nearest point on surface queries with configurable thresholds and normal-based filtering;</li> <li>\ud83d\udd27 External Tool Integration: Wraps powerful external tools like MeshFix for mesh repair and TetWild for tetrahedral mesh generation;</li> <li>\ud83d\udcd0 Barycentric Utilities: Includes functions for converting barycentric coordinates to points and sampling barycentric coordinates for simulation and analysis;</li> <li>\u2328\ufe0f Command-Line Interface: Offers a CLI for common tasks such as landmark annotation and mesh information display;</li> <li>\ud83c\udff7\ufe0f Type Safety: Utilizes modern Python type hints and static analysis tools for robust and maintainable code.</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>To install <code>liblaf-melon</code>, run the following command:</p> <pre><code>uv add liblaf-melon\n</code></pre>"},{"location":"#local-development","title":"\u2328\ufe0f Local Development","text":"<p>You can use Github Codespaces for online development:</p> <p></p> <p>Or clone it for local development:</p> <pre><code>gh repo clone liblaf/melon\ncd melon\nmise run install\n</code></pre>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions of all types are more than welcome, if you are interested in contributing code, feel free to check out our GitHub Issues to get stuck in to show us what you\u2019re made of.</p> <p></p> <p></p>"},{"location":"#more-projects","title":"\ud83d\udd17 More Projects","text":"<ul> <li>\ud83c\udf47 Grapes - Supercharge your Python with rich logging, precise timing, and seamless serialization.</li> <li>\ud83c\udf49 Melon - A comprehensive Python library for 3D mesh processing with advanced I/O capabilities, proximity analysis, and integration with external mesh processing tools.</li> <li>\ud83c\udf4a Tangerine - Squeeze dynamic content into your files with Tangerine\u2019s template magic.</li> <li>\ud83c\udf4b\u200d\ud83d\udfe9 Lime - AI-powered Git commit assistant and repository documentation generator</li> <li>\ud83c\udf4e Apple - A JAX and Warp library for differentiable physics simulation, featuring elastic energy models and finite element methods.</li> <li>\ud83c\udf52 Cherries - Sweet experiment tracking with Comet, DVC, and Git integration.</li> </ul>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>Copyright \u00a9 2025 liblaf.  This project is MIT licensed.</p>"},{"location":"reference/liblaf/melon/","title":"melon","text":""},{"location":"reference/liblaf/melon/#liblaf.melon","title":"liblaf.melon","text":"<p>Modules:</p> <ul> <li> <code>barycentric</code>           \u2013            </li> <li> <code>cli</code>           \u2013            </li> <li> <code>external</code>           \u2013            </li> <li> <code>io</code>           \u2013            </li> <li> <code>mesh</code>           \u2013            </li> <li> <code>proximity</code>           \u2013            </li> <li> <code>tetra</code>           \u2013            </li> <li> <code>tri</code>           \u2013            </li> <li> <code>typing</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>NearestAlgorithm</code>           \u2013            </li> <li> <code>NearestAlgorithmPrepared</code>           \u2013            </li> <li> <code>NearestPoint</code>           \u2013            </li> <li> <code>NearestPointOnSurface</code>           \u2013            </li> <li> <code>NearestPointOnSurfacePrepared</code>           \u2013            </li> <li> <code>NearestPointOnSurfaceResult</code>           \u2013            </li> <li> <code>NearestPointPrepared</code>           \u2013            </li> <li> <code>NearestPointResult</code>           \u2013            </li> <li> <code>NearestResult</code>           \u2013            </li> <li> <code>PVDWriter</code>           \u2013            <p>.</p> </li> <li> <code>SeriesReader</code>           \u2013            </li> <li> <code>SeriesWriter</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>annotate_landmarks</code>             \u2013              </li> <li> <code>as_mesh</code>             \u2013              </li> <li> <code>barycentric_to_points</code>             \u2013              </li> <li> <code>fast_wrapping</code>             \u2013              </li> <li> <code>get_landmarks_path</code>             \u2013              </li> <li> <code>get_polygons_path</code>             \u2013              </li> <li> <code>load_landmarks</code>             \u2013              </li> <li> <code>load_polygons</code>             \u2013              </li> <li> <code>mesh_fix</code>             \u2013              </li> <li> <code>nearest</code>             \u2013              </li> <li> <code>sample_barycentric_coords</code>             \u2013              </li> <li> <code>save_landmarks</code>             \u2013              </li> <li> <code>save_polygons</code>             \u2013              </li> <li> <code>tetwild</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>__version__</code>               (<code>str</code>)           \u2013            </li> <li> <code>__version_tuple__</code>               (<code>tuple[int | str, ...]</code>)           \u2013            </li> <li> <code>as_pointset</code>               (<code>ConverterDispatcher[PointSet]</code>)           \u2013            </li> <li> <code>as_polydata</code>               (<code>ConverterDispatcher[PolyData]</code>)           \u2013            </li> <li> <code>as_structured_grid</code>               (<code>ConverterDispatcher[StructuredGrid]</code>)           \u2013            </li> <li> <code>as_trimesh</code>               (<code>ConverterDispatcher[Trimesh]</code>)           \u2013            </li> <li> <code>as_unstructured_grid</code>               (<code>ConverterDispatcher[UnstructuredGrid]</code>)           \u2013            </li> <li> <code>load_polydata</code>               (<code>ReaderDispatcher[PolyData]</code>)           \u2013            </li> <li> <code>load_structured_grid</code>               (<code>ReaderDispatcher[StructuredGrid]</code>)           \u2013            </li> <li> <code>load_trimesh</code>               (<code>ReaderDispatcher[Trimesh]</code>)           \u2013            </li> <li> <code>load_unstructured_grid</code>               (<code>ReaderDispatcher[UnstructuredGrid]</code>)           \u2013            </li> <li> <code>save</code>           \u2013            </li> <li> <code>version</code>               (<code>str</code>)           \u2013            </li> <li> <code>version_tuple</code>               (<code>tuple[int | str, ...]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/#liblaf.melon.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__: str = '0.8.2.dev3+g89ba23713'\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.__version_tuple__","title":"__version_tuple__  <code>module-attribute</code>","text":"<pre><code>__version_tuple__: tuple[int | str, ...] = (\n    0,\n    8,\n    2,\n    \"dev3\",\n    \"g89ba23713\",\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.as_pointset","title":"as_pointset  <code>module-attribute</code>","text":"<pre><code>as_pointset: ConverterDispatcher[PointSet] = (\n    ConverterDispatcher(PointSet)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.as_polydata","title":"as_polydata  <code>module-attribute</code>","text":"<pre><code>as_polydata: ConverterDispatcher[PolyData] = (\n    ConverterDispatcher(PolyData)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.as_structured_grid","title":"as_structured_grid  <code>module-attribute</code>","text":"<pre><code>as_structured_grid: ConverterDispatcher[StructuredGrid] = (\n    ConverterDispatcher(StructuredGrid)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.as_trimesh","title":"as_trimesh  <code>module-attribute</code>","text":"<pre><code>as_trimesh: ConverterDispatcher[Trimesh] = (\n    ConverterDispatcher(Trimesh)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.as_unstructured_grid","title":"as_unstructured_grid  <code>module-attribute</code>","text":"<pre><code>as_unstructured_grid: ConverterDispatcher[\n    UnstructuredGrid\n] = ConverterDispatcher(UnstructuredGrid)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.load_polydata","title":"load_polydata  <code>module-attribute</code>","text":"<pre><code>load_polydata: ReaderDispatcher[PolyData] = (\n    ReaderDispatcher(PolyData)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.load_structured_grid","title":"load_structured_grid  <code>module-attribute</code>","text":"<pre><code>load_structured_grid: ReaderDispatcher[StructuredGrid] = (\n    ReaderDispatcher(StructuredGrid)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.load_trimesh","title":"load_trimesh  <code>module-attribute</code>","text":"<pre><code>load_trimesh: ReaderDispatcher[Trimesh] = ReaderDispatcher(\n    Trimesh\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.load_unstructured_grid","title":"load_unstructured_grid  <code>module-attribute</code>","text":"<pre><code>load_unstructured_grid: ReaderDispatcher[\n    UnstructuredGrid\n] = ReaderDispatcher(UnstructuredGrid)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.save","title":"save  <code>module-attribute</code>","text":"<pre><code>save = WriterDispatcher()\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.version","title":"version  <code>module-attribute</code>","text":"<pre><code>version: str = '0.8.2.dev3+g89ba23713'\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.version_tuple","title":"version_tuple  <code>module-attribute</code>","text":"<pre><code>version_tuple: tuple[int | str, ...] = (\n    0,\n    8,\n    2,\n    \"dev3\",\n    \"g89ba23713\",\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestAlgorithm","title":"NearestAlgorithm","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestAlgorithm.prepare","title":"prepare  <code>abstractmethod</code>","text":"<pre><code>prepare(source: Any) -&gt; NearestAlgorithmPrepared\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_abc.py</code> <pre><code>@abc.abstractmethod\ndef prepare(self, source: Any) -&gt; NearestAlgorithmPrepared: ...\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestAlgorithmPrepared","title":"NearestAlgorithmPrepared","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestAlgorithmPrepared.query","title":"query  <code>abstractmethod</code>","text":"<pre><code>query(query: Any) -&gt; NearestResult\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_abc.py</code> <pre><code>@abc.abstractmethod\ndef query(self, query: Any) -&gt; NearestResult: ...\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPoint","title":"NearestPoint","text":"<p>               Bases: <code>NearestAlgorithm</code></p> <p>Parameters:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>, default:                   <code>32</code> )           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>, default:                   <code>-inf</code> )           \u2013            </li> <li> <code>workers</code>               (<code>int</code>, default:                   <code>-1</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPoint.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPoint.ignore_orientation","title":"ignore_orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_orientation: bool = True\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPoint.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPoint.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = field(\n    default=-inf, validator=le(1.0)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPoint.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPoint.prepare","title":"prepare","text":"<pre><code>prepare(source: Any) -&gt; NearestPointPrepared\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_nearest_point.py</code> <pre><code>@override\ndef prepare(self, source: Any) -&gt; NearestPointPrepared:\n    need_normals: bool = self.normal_threshold &gt; -1.0\n    source: pv.PointSet = io.as_pointset(source, point_normals=need_normals)\n    tree: scipy.spatial.KDTree = scipy.spatial.KDTree(source.points)\n    return NearestPointPrepared(\n        source=source,\n        tree=tree,\n        distance_threshold=self.distance_threshold,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        ignore_orientation=self.ignore_orientation,\n        workers=self.workers,\n    )\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurface","title":"NearestPointOnSurface","text":"<p>               Bases: <code>NearestAlgorithm</code></p> <p>Parameters:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>, default:                   <code>32</code> )           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>, default:                   <code>0.8</code> )           \u2013            </li> <li> <code>workers</code>               (<code>int</code>, default:                   <code>-1</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurface.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurface.fallback_to_nearest_vertex","title":"fallback_to_nearest_vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fallback_to_nearest_vertex: bool = True\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurface.ignore_orientation","title":"ignore_orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_orientation: bool = True\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurface.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurface.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = field(\n    default=0.8, validator=le(1.0)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurface.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurface.prepare","title":"prepare","text":"<pre><code>prepare(source: Any) -&gt; NearestPointOnSurfacePrepared\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_nearest_point_on_surface.py</code> <pre><code>@override\ndef prepare(self, source: Any) -&gt; NearestPointOnSurfacePrepared:\n    source: tm.Trimesh = io.as_trimesh(source)\n    return NearestPointOnSurfacePrepared(\n        distance_threshold=self.distance_threshold,\n        fallback_to_nearest_vertex=self.fallback_to_nearest_vertex,\n        ignore_orientation=self.ignore_orientation,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        workers=self.workers,\n        source=source,\n    )\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared","title":"NearestPointOnSurfacePrepared","text":"<p>               Bases: <code>NearestAlgorithmPrepared</code></p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>Trimesh</code>)           \u2013            </li> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>source</code>               (<code>Trimesh</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.distance_threshold","title":"distance_threshold  <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.fallback_to_nearest_vertex","title":"fallback_to_nearest_vertex  <code>instance-attribute</code>","text":"<pre><code>fallback_to_nearest_vertex: bool\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.ignore_orientation","title":"ignore_orientation  <code>instance-attribute</code>","text":"<pre><code>ignore_orientation: bool\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.max_k","title":"max_k  <code>instance-attribute</code>","text":"<pre><code>max_k: int\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.normal_threshold","title":"normal_threshold  <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: Trimesh\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers: int\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfacePrepared.query","title":"query","text":"<pre><code>query(query: Any) -&gt; NearestPointOnSurfaceResult\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_nearest_point_on_surface.py</code> <pre><code>@override\ndef query(self, query: Any) -&gt; NearestPointOnSurfaceResult:\n    need_normals: bool = self.normal_threshold &gt; -1.0\n    query: pv.PointSet = io.as_pointset(query, point_normals=need_normals)\n    nearest: Float[np.ndarray, \"N 3\"]\n    distance: Float[np.ndarray, \" N\"]\n    triangle_id: Integer[np.ndarray, \" N\"]\n    nearest, distance, triangle_id = self.source.nearest.on_surface(query.points)\n    missing: Bool[np.ndarray, \" N\"] = (\n        distance &gt; self.distance_threshold * self.source.scale\n    )\n    if need_normals:\n        source_normals: Float[np.ndarray, \"N 3\"] = self.source.face_normals[\n            triangle_id\n        ]\n        target_normals: Float[np.ndarray, \"N 3\"] = query.point_data[\"Normals\"]\n        cosine_similarity: Float[np.ndarray, \" N\"] = np.vecdot(\n            source_normals, target_normals\n        )\n        if self.ignore_orientation:\n            cosine_similarity = np.abs(cosine_similarity)\n        missing |= cosine_similarity &lt; self.normal_threshold\n    distance[missing] = np.inf\n    nearest[missing] = np.nan\n    triangle_id[missing] = -1\n    result = NearestPointOnSurfaceResult(\n        distance=distance, missing=missing, nearest=nearest, triangle_id=triangle_id\n    )\n    if self.fallback_to_nearest_vertex:\n        result = self._fallback_to_nearest_vertex(query, result)\n    return result\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfaceResult","title":"NearestPointOnSurfaceResult","text":"<p>               Bases: <code>NearestResult</code></p> <p>Parameters:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, Q]</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, Q]</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> <li> <code>triangle_id</code>               (<code>Integer[ndarray, N]</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> <li> <code>triangle_id</code>               (<code>Integer[ndarray, ' N']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfaceResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfaceResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfaceResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, 'Q 3']\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointOnSurfaceResult.triangle_id","title":"triangle_id  <code>instance-attribute</code>","text":"<pre><code>triangle_id: Integer[ndarray, ' N']\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointPrepared","title":"NearestPointPrepared","text":"<p>               Bases: <code>NearestAlgorithmPrepared</code></p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>PointSet</code>)           \u2013            </li> <li> <code>tree</code>               (<code>KDTree</code>)           \u2013            </li> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>source</code>               (<code>PointSet</code>)           \u2013            </li> <li> <code>tree</code>               (<code>KDTree</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointPrepared.distance_threshold","title":"distance_threshold  <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointPrepared.ignore_orientation","title":"ignore_orientation  <code>instance-attribute</code>","text":"<pre><code>ignore_orientation: bool\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointPrepared.max_k","title":"max_k  <code>instance-attribute</code>","text":"<pre><code>max_k: int\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointPrepared.normal_threshold","title":"normal_threshold  <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointPrepared.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: PointSet\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointPrepared.tree","title":"tree  <code>instance-attribute</code>","text":"<pre><code>tree: KDTree\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointPrepared.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers: int\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointPrepared.query","title":"query","text":"<pre><code>query(query: Any) -&gt; NearestPointResult\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_nearest_point.py</code> <pre><code>@override\ndef query(self, query: Any) -&gt; NearestPointResult:\n    if self.normal_threshold &lt;= -1.0:\n        return self._nearest_vertex(query)\n    return self._nearest_vertex_with_normal_threshold(query)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointResult","title":"NearestPointResult","text":"<p>               Bases: <code>NearestResult</code></p> <p>Parameters:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, Q]</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, Q]</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> <li> <code>vertex_id</code>               (<code>Integer[ndarray, N]</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> <li> <code>vertex_id</code>               (<code>Integer[ndarray, ' N']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, 'Q 3']\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestPointResult.vertex_id","title":"vertex_id  <code>instance-attribute</code>","text":"<pre><code>vertex_id: Integer[ndarray, ' N']\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestResult","title":"NearestResult","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parameters:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, Q]</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, Q]</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.NearestResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, 'Q 3']\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.PVDWriter","title":"PVDWriter","text":"<p>.</p> References <p>[1]: ParaView/Data formats - KitwarePublic</p> <p>Parameters:</p> <ul> <li> <code>clear</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>file</code>               (<code>Path</code>, default:                   <code>PosixPath('animation.pvd')</code> )           \u2013            </li> <li> <code>fps</code>               (<code>float</code>, default:                   <code>30.0</code> )           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>datasets</code>               (<code>list[PVDDataSet]</code>)           \u2013            <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__attrs_post_init__</code>             \u2013              </li> <li> <code>append</code>             \u2013              </li> <li> <code>end</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/#liblaf.melon.PVDWriter.clear","title":"clear  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clear: bool = field(default=False, kw_only=True)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.PVDWriter.datasets","title":"datasets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>datasets: list[PVDDataSet] = field(init=False, factory=list)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.PVDWriter.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: Path = field(\n    default=Path(\"animation.pvd\"), converter=Path\n)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.PVDWriter.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.PVDWriter.fps","title":"fps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fps: float = field(default=30.0, kw_only=True)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.PVDWriter.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.PVDWriter.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/_pvd_writer.py</code> <pre><code>def __attrs_post_init__(self) -&gt; None:\n    if self.clear:\n        shutil.rmtree(self.folder, ignore_errors=True)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.PVDWriter.append","title":"append","text":"<pre><code>append(\n    dataset: Any,\n    timestep: float | None = None,\n    *,\n    ext: str,\n    part: int = 0,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/_pvd_writer.py</code> <pre><code>def append(\n    self, dataset: Any, timestep: float | None = None, *, ext: str, part: int = 0\n) -&gt; None:\n    if timestep is None:\n        timestep = (\n            self.datasets[-1].timestep + (1 / self.fps) if self.datasets else 0\n        )\n    frame_id: int = len(self.datasets)\n    filename: str = f\"{self.name}_{frame_id:06d}\"\n    filename += ext\n    filepath: Path = self.folder / filename\n    save(filepath, dataset)\n    self.datasets.append(PVDDataSet(timestep=timestep, part=part, file=filepath))\n    self.end()\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.PVDWriter.end","title":"end","text":"<pre><code>end() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/_pvd_writer.py</code> <pre><code>def end(self) -&gt; None:\n    root = ElementTree.Element(\n        \"VTKFile\", type=\"Collection\", version=\"0.1\", byte_order=\"LittleEndian\"\n    )\n    collection: ElementTree.Element = ElementTree.SubElement(root, \"Collection\")\n    root_dir: Path = self.file.absolute().parent\n    for dataset in self.datasets:\n        elem: ElementTree.Element = ElementTree.SubElement(collection, \"DataSet\")\n        elem.set(\"timestep\", str(dataset.timestep))\n        elem.set(\"part\", str(dataset.part))\n        elem.set(\"file\", dataset.file.absolute().relative_to(root_dir).as_posix())\n    tree = ElementTree.ElementTree(root)\n    ElementTree.indent(tree, space=\"  \")\n    self.file.parent.mkdir(parents=True, exist_ok=True)\n    tree.write(self.file, xml_declaration=True)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesReader","title":"SeriesReader","text":"<pre><code>SeriesReader(file: PathLike, loader: Callable[[Path], T])\n</code></pre> <p>               Bases: <code>Sequence[T]</code></p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>loader</code>               (<code>Callable[list, T]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>folder</code>               (<code>Path</code>)           \u2013            </li> <li> <code>loader</code>               (<code>Callable[[Path], T]</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>time_values</code>               (<code>list[float]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>def __init__(self, file: PathLike, loader: Callable[[Path], T]) -&gt; None:\n    file = Path(file)\n    self.__attrs_init__(file=file, loader=loader)  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesReader.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file: Path\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesReader.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesReader.loader","title":"loader  <code>instance-attribute</code>","text":"<pre><code>loader: Callable[[Path], T]\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesReader.series","title":"series  <code>cached</code> <code>property</code>","text":"<pre><code>series: Series\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesReader.time_values","title":"time_values  <code>property</code>","text":"<pre><code>time_values: list[float]\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesReader.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; T\n</code></pre><pre><code>__getitem__(index: slice) -&gt; Sequence[T]\n</code></pre> <pre><code>__getitem__(index: int | slice) -&gt; T | Sequence[T]\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>@override\ndef __getitem__(self, index: int | slice) -&gt; T | Sequence[T]:\n    __tracebackhide__ = True\n    files: File | list[File] = self.series.files[index]\n    if isinstance(files, File):\n        return self.loader(self.folder / files.name)\n    return [self.loader(self.folder / f.name) for f in files]\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesReader.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    return len(self.series.files)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter","title":"SeriesWriter","text":"<pre><code>SeriesWriter(\n    file: PathLike,\n    /,\n    *,\n    clear: bool = False,\n    fps: float = 30.0,\n    step: float | None = None,\n)\n</code></pre> <p>               Bases: <code>Sequence[File]</code>, <code>AbstractContextManager</code></p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>step</code>               (<code>float</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__enter__</code>             \u2013              </li> <li> <code>__exit__</code>             \u2013              </li> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>append</code>             \u2013              </li> <li> <code>end</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>start</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>ext</code>               (<code>str</code>)           \u2013            </li> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>folder</code>               (<code>Path</code>)           \u2013            </li> <li> <code>fps</code>               (<code>float</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>step</code>               (<code>float</code>)           \u2013            </li> <li> <code>time</code>               (<code>float</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __init__(\n    self,\n    file: PathLike,\n    /,\n    *,\n    clear: bool = False,\n    fps: float = 30.0,\n    step: float | None = None,\n) -&gt; None:\n    if step is None:\n        step = 1.0 / fps\n    self.__attrs_init__(file=Path(file), series=Series(), step=step)  # pyright: ignore[reportAttributeAccessIssue]\n    if clear:\n        shutil.rmtree(self.folder, ignore_errors=True)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.ext","title":"ext  <code>property</code>","text":"<pre><code>ext: str\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file: Path\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.fps","title":"fps  <code>property</code>","text":"<pre><code>fps: float\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.series","title":"series  <code>instance-attribute</code>","text":"<pre><code>series: Series\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step: float\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.time","title":"time  <code>property</code>","text":"<pre><code>time: float\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.__exit__","title":"__exit__","text":"<pre><code>__exit__(\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: types.TracebackType | None,\n) -&gt; None:\n    self.end()\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; File\n</code></pre><pre><code>__getitem__(index: slice) -&gt; list[File]\n</code></pre> <pre><code>__getitem__(index: int | slice) -&gt; File | list[File]\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __getitem__(self, index: int | slice) -&gt; File | list[File]:\n    return self.series.files[index]\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.series.files)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.append","title":"append","text":"<pre><code>append(\n    data: Any,\n    *,\n    time: float | None = None,\n    timestep: float | None = None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def append(\n    self, data: Any, *, time: float | None = None, timestep: float | None = None\n) -&gt; None:\n    __tracebackhide__ = True\n    filename: str = f\"{self.name}_{len(self):06d}{self.ext}\"\n    filepath: Path = self.folder / filename\n    save(filepath, data)\n    if time is None:\n        if timestep is None:\n            timestep = self.step\n        time = self.time + timestep\n    self.series.files.append(\n        File(name=filepath.relative_to(self.file.parent).as_posix(), time=time)\n    )\n    self.save()\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.end","title":"end","text":"<pre><code>end() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def end(self) -&gt; None:\n    self.save()\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.save","title":"save","text":"<pre><code>save() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def save(self) -&gt; None:\n    grapes.save(\n        self.file, self.series, force_ext=\".json\", pydantic={\"by_alias\": True}\n    )\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.SeriesWriter.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def start(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.annotate_landmarks","title":"annotate_landmarks","text":"<pre><code>annotate_landmarks(\n    left: Any,\n    right: Any,\n    *,\n    left_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    right_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n) -&gt; tuple[Float[ndarray, \"L 3\"], Float[ndarray, \"L 3\"]]\n</code></pre> Source code in <code>src/liblaf/melon/external/wrap/_annotate_landmarks.py</code> <pre><code>def annotate_landmarks(\n    left: Any,\n    right: Any,\n    *,\n    left_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    right_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n) -&gt; tuple[Float[np.ndarray, \"L 3\"], Float[np.ndarray, \"L 3\"]]:\n    if left_landmarks is None:\n        left_landmarks = np.zeros((0, 3))\n    if right_landmarks is None:\n        right_landmarks = np.zeros((0, 3))\n    with tempfile.TemporaryDirectory() as tmpdir_str:\n        tmpdir: Path = Path(tmpdir_str).absolute()\n        project_file: Path = tmpdir / \"annotate-landmarks.wrap\"\n        left_file: Path = tmpdir / \"left.obj\"\n        right_file: Path = tmpdir / \"right.obj\"\n        left_landmarks_file: Path = tmpdir / \"left.landmarks.json\"\n        right_landmarks_file: Path = tmpdir / \"right.landmarks.json\"\n        io.save(left_file, left)\n        io.save(right_file, right)\n        io.save_landmarks(left_landmarks_file, left_landmarks)\n        io.save_landmarks(right_landmarks_file, right_landmarks)\n        template: jinja2.Template = environment.get_template(\"annotate-landmarks.wrap\")\n        project: str = template.render(\n            {\n                \"left\": left_file,\n                \"right\": right_file,\n                \"left_landmarks\": left_landmarks_file,\n                \"right_landmarks\": right_landmarks_file,\n            }\n        )\n        project_file.write_text(project)\n        sp.run([\"Wrap.sh\", project_file], check=True)\n        left_landmarks = io.load_landmarks(left_landmarks_file)\n        right_landmarks = io.load_landmarks(right_landmarks_file)\n    return left_landmarks, right_landmarks\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.as_mesh","title":"as_mesh","text":"<pre><code>as_mesh(mesh: Any) -&gt; PolyData | UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/_convert.py</code> <pre><code>def as_mesh(mesh: Any) -&gt; pv.PolyData | pv.UnstructuredGrid:\n    try:\n        return as_polydata(mesh)\n    except UnsupportedConverterError:\n        pass\n    return as_unstructured_grid(mesh)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.barycentric_to_points","title":"barycentric_to_points","text":"<pre><code>barycentric_to_points(\n    cells: Float[ArrayLike, \"*N B D\"],\n    barycentric: Float[ArrayLike, \"*N B\"],\n) -&gt; Float[ndarray, \"*N D\"]\n</code></pre> Source code in <code>src/liblaf/melon/barycentric/_points.py</code> <pre><code>def barycentric_to_points(\n    cells: Float[ArrayLike, \"*N B D\"], barycentric: Float[ArrayLike, \"*N B\"]\n) -&gt; Float[np.ndarray, \"*N D\"]:\n    cells: Float[np.ndarray, \"*N B D\"] = np.asarray(cells)\n    barycentric: Float[np.ndarray, \"*N B\"] = np.asarray(barycentric)\n    points: Float[np.ndarray, \"*N D\"] = einops.einsum(\n        barycentric, cells, \"... B, ... B D -&gt; ... D\"\n    )\n    return points\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.fast_wrapping","title":"fast_wrapping","text":"<pre><code>fast_wrapping(\n    source: Any,\n    target: Any,\n    *,\n    source_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    target_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    free_polygons_floating: Integer[ArrayLike, \" F\"]\n    | None = None,\n    verbose: bool = True,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/external/wrap/_fast_wrapping.py</code> <pre><code>def fast_wrapping(\n    source: Any,\n    target: Any,\n    *,\n    source_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    target_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    free_polygons_floating: Integer[ArrayLike, \" F\"] | None = None,\n    verbose: bool = True,\n) -&gt; pv.PolyData:\n    source_landmarks = source_landmarks if source_landmarks is not None else []\n    target_landmarks = target_landmarks if target_landmarks is not None else []\n    free_polygons_floating = (\n        free_polygons_floating if free_polygons_floating is not None else []\n    )\n    with tempfile.TemporaryDirectory(delete=False) as tmpdir_str:\n        tmpdir: Path = Path(tmpdir_str).absolute()\n        project_file: Path = tmpdir / \"fast-wrapping.wrap\"\n        source_file: Path = tmpdir / \"source.obj\"\n        target_file: Path = tmpdir / \"target.obj\"\n        output_file: Path = tmpdir / \"output.obj\"\n        source_landmarks_file: Path = tmpdir / \"source.landmarks.json\"\n        target_landmarks_file: Path = tmpdir / \"target.landmarks.json\"\n        free_polygons_floating_file: Path = tmpdir / \"free-polygons-floating.json\"\n        io.save(source_file, source)\n        io.save(target_file, target)\n        io.save_landmarks(source_landmarks_file, source_landmarks)\n        io.save_landmarks(target_landmarks_file, target_landmarks)\n        io.save_polygons(free_polygons_floating_file, free_polygons_floating)\n        template: jinja2.Template = environment.get_template(\"fast-wrapping.wrap\")\n        project: str = template.render(\n            {\n                \"source\": str(source_file),\n                \"target\": str(target_file),\n                \"output\": str(output_file),\n                \"source_landmarks\": str(source_landmarks_file),\n                \"target_landmarks\": str(target_landmarks_file),\n                \"free_polygons_floating\": str(free_polygons_floating_file),\n            }\n        )\n        project_file.write_text(project)\n        args: list[str | os.PathLike] = [\"WrapCmd.sh\", \"compute\", project_file]\n        if verbose:\n            args.append(\"--verbose\")\n        sp.run(args, check=True)\n        return io.load_polydata(output_file)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.get_landmarks_path","title":"get_landmarks_path","text":"<pre><code>get_landmarks_path(path: str | PathLike[str]) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_utils.py</code> <pre><code>def get_landmarks_path(path: str | os.PathLike[str]) -&gt; Path:\n    path: Path = Path(path)\n    if path.suffix != \".json\":\n        return path.with_suffix(\".landmarks.json\")\n    return path\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.get_polygons_path","title":"get_polygons_path","text":"<pre><code>get_polygons_path(path: str | PathLike[str]) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_utils.py</code> <pre><code>def get_polygons_path(path: str | os.PathLike[str]) -&gt; Path:\n    path: Path = Path(path)\n    if path.suffix != \".json\":\n        return path.with_suffix(\".polygons.json\")\n    return path\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.load_landmarks","title":"load_landmarks","text":"<pre><code>load_landmarks(\n    path: str | PathLike[str],\n) -&gt; Float[ndarray, \"N 3\"]\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_reader.py</code> <pre><code>def load_landmarks(path: str | os.PathLike[str]) -&gt; Float[np.ndarray, \"N 3\"]:\n    path: Path = get_landmarks_path(path)\n    if not path.exists():\n        return np.empty((0, 3), dtype=float)\n    data: list[dict[str, float]] = grapes.load(path)\n    return np.asarray([[p[\"x\"], p[\"y\"], p[\"z\"]] for p in data])\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.load_polygons","title":"load_polygons","text":"<pre><code>load_polygons(path: PathLike) -&gt; Integer[ndarray, ' N']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_reader.py</code> <pre><code>def load_polygons(path: PathLike) -&gt; Integer[np.ndarray, \" N\"]:\n    path: Path = get_polygons_path(path)\n    data: list[int] = grapes.load(path)\n    return np.asarray(data)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.mesh_fix","title":"mesh_fix","text":"<pre><code>mesh_fix(\n    mesh: Any,\n    *,\n    check: bool = True,\n    verbose: bool = False,\n    joincomp: bool = False,\n    remove_smallest_components: bool = False,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/external/_mesh_fix.py</code> <pre><code>def mesh_fix(\n    mesh: Any,\n    *,\n    check: bool = True,\n    verbose: bool = False,\n    joincomp: bool = False,\n    remove_smallest_components: bool = False,\n) -&gt; pv.PolyData:\n    if grapes.has_module(\"pymeshfix\"):\n        result: pv.PolyData = _pymeshfix(\n            mesh,\n            verbose=verbose,\n            joincomp=joincomp,\n            remove_smallest_components=remove_smallest_components,\n        )\n    elif shutil.which(\"MeshFix\"):\n        result: pv.PolyData = _mesh_fix_exe(mesh, verbose=verbose)\n    else:\n        raise NotImplementedError\n    if check:\n        assert tri.is_volume(result)\n    mesh: pv.PolyData = io.as_polydata(mesh)\n    result.field_data.update(mesh.field_data)\n    return result\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.nearest","title":"nearest","text":"<pre><code>nearest(\n    source: Any,\n    query: Any,\n    algo: NearestPoint | None = None,\n) -&gt; NearestPointResult\n</code></pre><pre><code>nearest(\n    source: Any, query: Any, algo: NearestPointOnSurface\n) -&gt; NearestPointOnSurfaceResult\n</code></pre><pre><code>nearest(\n    source: Any, query: Any, algo: NearestAlgorithm\n) -&gt; NearestResult\n</code></pre> <pre><code>nearest(\n    source: Any,\n    query: Any,\n    algo: NearestAlgorithm | None = None,\n) -&gt; NearestResult\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_nearest.py</code> <pre><code>def nearest(\n    source: Any, query: Any, algo: NearestAlgorithm | None = None\n) -&gt; NearestResult:\n    if algo is None:\n        algo = NearestPoint()\n    prepared: NearestAlgorithmPrepared = algo.prepare(source)\n    return prepared.query(query)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.sample_barycentric_coords","title":"sample_barycentric_coords","text":"<pre><code>sample_barycentric_coords(\n    shape: tuple[int, int],\n    generator: Generator | None = None,\n) -&gt; Float[ndarray, \"N D\"]\n</code></pre> Source code in <code>src/liblaf/melon/barycentric/_sample.py</code> <pre><code>def sample_barycentric_coords(\n    shape: tuple[int, int], generator: np.random.Generator | None = None\n) -&gt; Float[np.ndarray, \"N D\"]:\n    if generator is None:\n        generator = np.random.default_rng()\n    n_samples: int = shape[0]\n    dim: int = shape[1]\n    coords: Float[np.ndarray, \"N D-1\"] = generator.uniform(0, 1, (n_samples, dim - 1))\n    coords: Float[np.ndarray, \"N D-1\"] = np.sort(coords, axis=1)\n    coords: Float[np.ndarray, \"N D\"] = np.diff(coords, axis=1, prepend=0, append=1)\n    return coords\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.save_landmarks","title":"save_landmarks","text":"<pre><code>save_landmarks(\n    path: str | PathLike[str],\n    points: Float[ArrayLike, \"N 3\"],\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_writer.py</code> <pre><code>def save_landmarks(\n    path: str | os.PathLike[str], points: Float[ArrayLike, \"N 3\"]\n) -&gt; None:\n    path: Path = get_landmarks_path(path)\n    points: Float[np.ndarray, \"N 3\"] = np.asarray(points)\n    data: list[dict[str, float]] = [\n        {\"x\": p[0], \"y\": p[1], \"z\": p[2]} for p in points.tolist()\n    ]\n    grapes.save(path, data)\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.save_polygons","title":"save_polygons","text":"<pre><code>save_polygons(\n    path: str | PathLike[str],\n    polygons: Integer[ArrayLike, \" N\"],\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_writer.py</code> <pre><code>def save_polygons(\n    path: str | os.PathLike[str], polygons: Integer[ArrayLike, \" N\"]\n) -&gt; None:\n    path: Path = get_polygons_path(path)\n    polygons = np.asarray(polygons)\n    grapes.save(path, polygons.tolist())\n</code></pre>"},{"location":"reference/liblaf/melon/#liblaf.melon.tetwild","title":"tetwild","text":"<pre><code>tetwild(\n    surface: Any,\n    *,\n    fix_winding: bool = True,\n    lr: float | None = None,\n    epsr: float | None = None,\n    level: int | None = None,\n    color: bool = False,\n    coarsen: bool = False,\n    csg: bool = False,\n    **kwargs,\n) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/external/_tetwild.py</code> <pre><code>def tetwild(\n    surface: Any,\n    *,\n    fix_winding: bool = True,\n    lr: float | None = None,\n    epsr: float | None = None,\n    level: int | None = None,\n    color: bool = False,\n    coarsen: bool = False,\n    csg: bool = False,\n    **kwargs,\n) -&gt; pv.UnstructuredGrid:\n    surface: pv.PolyData = copy_structure(surface)  # pyright: ignore[reportAssignmentType]\n    if shutil.which(\"fTetWild\"):\n        mesh: pv.UnstructuredGrid = _tetwild_exe(\n            surface,\n            lr=lr,\n            epsr=epsr,\n            level=level,\n            no_color=not color,\n            csg=csg,\n            coarsen=coarsen,\n            **kwargs,\n        )\n    else:\n        raise NotImplementedError\n    if fix_winding:\n        mesh = tetra.fix_winding(mesh)\n    return mesh\n</code></pre>"},{"location":"reference/liblaf/melon/barycentric/","title":"barycentric","text":""},{"location":"reference/liblaf/melon/barycentric/#liblaf.melon.barycentric","title":"liblaf.melon.barycentric","text":"<p>Functions:</p> <ul> <li> <code>barycentric_to_points</code>             \u2013              </li> <li> <code>sample_barycentric_coords</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/barycentric/#liblaf.melon.barycentric.barycentric_to_points","title":"barycentric_to_points","text":"<pre><code>barycentric_to_points(\n    cells: Float[ArrayLike, \"*N B D\"],\n    barycentric: Float[ArrayLike, \"*N B\"],\n) -&gt; Float[ndarray, \"*N D\"]\n</code></pre> Source code in <code>src/liblaf/melon/barycentric/_points.py</code> <pre><code>def barycentric_to_points(\n    cells: Float[ArrayLike, \"*N B D\"], barycentric: Float[ArrayLike, \"*N B\"]\n) -&gt; Float[np.ndarray, \"*N D\"]:\n    cells: Float[np.ndarray, \"*N B D\"] = np.asarray(cells)\n    barycentric: Float[np.ndarray, \"*N B\"] = np.asarray(barycentric)\n    points: Float[np.ndarray, \"*N D\"] = einops.einsum(\n        barycentric, cells, \"... B, ... B D -&gt; ... D\"\n    )\n    return points\n</code></pre>"},{"location":"reference/liblaf/melon/barycentric/#liblaf.melon.barycentric.sample_barycentric_coords","title":"sample_barycentric_coords","text":"<pre><code>sample_barycentric_coords(\n    shape: tuple[int, int],\n    generator: Generator | None = None,\n) -&gt; Float[ndarray, \"N D\"]\n</code></pre> Source code in <code>src/liblaf/melon/barycentric/_sample.py</code> <pre><code>def sample_barycentric_coords(\n    shape: tuple[int, int], generator: np.random.Generator | None = None\n) -&gt; Float[np.ndarray, \"N D\"]:\n    if generator is None:\n        generator = np.random.default_rng()\n    n_samples: int = shape[0]\n    dim: int = shape[1]\n    coords: Float[np.ndarray, \"N D-1\"] = generator.uniform(0, 1, (n_samples, dim - 1))\n    coords: Float[np.ndarray, \"N D-1\"] = np.sort(coords, axis=1)\n    coords: Float[np.ndarray, \"N D\"] = np.diff(coords, axis=1, prepend=0, append=1)\n    return coords\n</code></pre>"},{"location":"reference/liblaf/melon/cli/","title":"cli","text":""},{"location":"reference/liblaf/melon/cli/#liblaf.melon.cli","title":"liblaf.melon.cli","text":"<p>Functions:</p> <ul> <li> <code>annotate_landmarks</code>             \u2013              </li> <li> <code>info</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>app</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/cli/#liblaf.melon.cli.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = App(name='melon', version=__version__)\n</code></pre>"},{"location":"reference/liblaf/melon/cli/#liblaf.melon.cli.annotate_landmarks","title":"annotate_landmarks","text":"<pre><code>annotate_landmarks(\n    left_path: Annotated[Path, Parameter(left)],\n    right_path: Annotated[Path, Parameter(right)],\n    /,\n    *,\n    left_landmarks_path: Annotated[\n        Path | None, Parameter(left - landmarks)\n    ] = None,\n    right_landmarks_path: Annotated[\n        Path | None, Parameter(right - landmarks)\n    ] = None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/cli/_annotate_landmarks.py</code> <pre><code>def annotate_landmarks(\n    left_path: Annotated[Path, cyclopts.Parameter(\"left\")],\n    right_path: Annotated[Path, cyclopts.Parameter(\"right\")],\n    /,\n    *,\n    left_landmarks_path: Annotated[\n        Path | None, cyclopts.Parameter(\"left-landmarks\")\n    ] = None,\n    right_landmarks_path: Annotated[\n        Path | None, cyclopts.Parameter(\"right-landmarks\")\n    ] = None,\n) -&gt; None:\n    if left_landmarks_path is None:\n        left_landmarks_path = left_path\n    if right_landmarks_path is None:\n        right_landmarks_path = right_path\n    left: pv.PolyData = io.load_polydata(left_path)\n    left_landmarks: Float[np.ndarray, \"landmarks 3\"] = io.load_landmarks(\n        left_landmarks_path\n    )\n    right: pv.PolyData = io.load_polydata(right_path)\n    right_landmarks: Float[np.ndarray, \"landmarks 3\"] = io.load_landmarks(\n        right_landmarks_path\n    )\n    left_landmarks, right_landmarks = external.annotate_landmarks(\n        left, right, left_landmarks=left_landmarks, right_landmarks=right_landmarks\n    )\n    io.save_landmarks(left_landmarks_path, left_landmarks)\n    io.save_landmarks(right_landmarks_path, right_landmarks)\n</code></pre>"},{"location":"reference/liblaf/melon/cli/#liblaf.melon.cli.info","title":"info","text":"<pre><code>info(\n    path: Path,\n    /,\n    *,\n    point_data: bool = True,\n    cell_data: bool = True,\n    field_data: bool = True,\n    field_data_values: bool = False,\n    user_dict: bool = True,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/cli/_info.py</code> <pre><code>def info(\n    path: Path,\n    /,\n    *,\n    point_data: bool = True,\n    cell_data: bool = True,\n    field_data: bool = True,\n    field_data_values: bool = False,\n    user_dict: bool = True,\n) -&gt; None:\n    mesh: pv.PolyData | pv.UnstructuredGrid\n    if path.suffix in POLY_DATA_SUFFIXES:\n        mesh = io.load_polydata(path)\n    elif path.suffix in UNSTRUCTURED_GRID_SUFFIXES:\n        mesh = io.load_unstructured_grid(path)\n    else:\n        msg: str = f\"Unsupported file format: {path.suffix}\"\n        raise ValueError(msg)\n    rich.pretty.pprint(mesh)\n    if point_data:\n        rich.pretty.pprint(mesh.point_data)\n    if cell_data:\n        rich.pretty.pprint(mesh.cell_data)\n    if field_data:\n        rich.pretty.pprint(mesh.field_data)\n    if field_data_values:\n        for name, data in mesh.field_data.items():\n            rich.print(f\"{name}: \", end=\"\")\n            rich.pretty.pprint(data)\n    if user_dict:\n        rich.print(\"User Dict: \", end=\"\")\n        rich.pretty.pprint(mesh.user_dict)\n</code></pre>"},{"location":"reference/liblaf/melon/external/","title":"external","text":""},{"location":"reference/liblaf/melon/external/#liblaf.melon.external","title":"liblaf.melon.external","text":"<p>Modules:</p> <ul> <li> <code>wrap</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>annotate_landmarks</code>             \u2013              </li> <li> <code>fast_wrapping</code>             \u2013              </li> <li> <code>mesh_fix</code>             \u2013              </li> <li> <code>tetwild</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/external/#liblaf.melon.external.annotate_landmarks","title":"annotate_landmarks","text":"<pre><code>annotate_landmarks(\n    left: Any,\n    right: Any,\n    *,\n    left_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    right_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n) -&gt; tuple[Float[ndarray, \"L 3\"], Float[ndarray, \"L 3\"]]\n</code></pre> Source code in <code>src/liblaf/melon/external/wrap/_annotate_landmarks.py</code> <pre><code>def annotate_landmarks(\n    left: Any,\n    right: Any,\n    *,\n    left_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    right_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n) -&gt; tuple[Float[np.ndarray, \"L 3\"], Float[np.ndarray, \"L 3\"]]:\n    if left_landmarks is None:\n        left_landmarks = np.zeros((0, 3))\n    if right_landmarks is None:\n        right_landmarks = np.zeros((0, 3))\n    with tempfile.TemporaryDirectory() as tmpdir_str:\n        tmpdir: Path = Path(tmpdir_str).absolute()\n        project_file: Path = tmpdir / \"annotate-landmarks.wrap\"\n        left_file: Path = tmpdir / \"left.obj\"\n        right_file: Path = tmpdir / \"right.obj\"\n        left_landmarks_file: Path = tmpdir / \"left.landmarks.json\"\n        right_landmarks_file: Path = tmpdir / \"right.landmarks.json\"\n        io.save(left_file, left)\n        io.save(right_file, right)\n        io.save_landmarks(left_landmarks_file, left_landmarks)\n        io.save_landmarks(right_landmarks_file, right_landmarks)\n        template: jinja2.Template = environment.get_template(\"annotate-landmarks.wrap\")\n        project: str = template.render(\n            {\n                \"left\": left_file,\n                \"right\": right_file,\n                \"left_landmarks\": left_landmarks_file,\n                \"right_landmarks\": right_landmarks_file,\n            }\n        )\n        project_file.write_text(project)\n        sp.run([\"Wrap.sh\", project_file], check=True)\n        left_landmarks = io.load_landmarks(left_landmarks_file)\n        right_landmarks = io.load_landmarks(right_landmarks_file)\n    return left_landmarks, right_landmarks\n</code></pre>"},{"location":"reference/liblaf/melon/external/#liblaf.melon.external.fast_wrapping","title":"fast_wrapping","text":"<pre><code>fast_wrapping(\n    source: Any,\n    target: Any,\n    *,\n    source_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    target_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    free_polygons_floating: Integer[ArrayLike, \" F\"]\n    | None = None,\n    verbose: bool = True,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/external/wrap/_fast_wrapping.py</code> <pre><code>def fast_wrapping(\n    source: Any,\n    target: Any,\n    *,\n    source_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    target_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    free_polygons_floating: Integer[ArrayLike, \" F\"] | None = None,\n    verbose: bool = True,\n) -&gt; pv.PolyData:\n    source_landmarks = source_landmarks if source_landmarks is not None else []\n    target_landmarks = target_landmarks if target_landmarks is not None else []\n    free_polygons_floating = (\n        free_polygons_floating if free_polygons_floating is not None else []\n    )\n    with tempfile.TemporaryDirectory(delete=False) as tmpdir_str:\n        tmpdir: Path = Path(tmpdir_str).absolute()\n        project_file: Path = tmpdir / \"fast-wrapping.wrap\"\n        source_file: Path = tmpdir / \"source.obj\"\n        target_file: Path = tmpdir / \"target.obj\"\n        output_file: Path = tmpdir / \"output.obj\"\n        source_landmarks_file: Path = tmpdir / \"source.landmarks.json\"\n        target_landmarks_file: Path = tmpdir / \"target.landmarks.json\"\n        free_polygons_floating_file: Path = tmpdir / \"free-polygons-floating.json\"\n        io.save(source_file, source)\n        io.save(target_file, target)\n        io.save_landmarks(source_landmarks_file, source_landmarks)\n        io.save_landmarks(target_landmarks_file, target_landmarks)\n        io.save_polygons(free_polygons_floating_file, free_polygons_floating)\n        template: jinja2.Template = environment.get_template(\"fast-wrapping.wrap\")\n        project: str = template.render(\n            {\n                \"source\": str(source_file),\n                \"target\": str(target_file),\n                \"output\": str(output_file),\n                \"source_landmarks\": str(source_landmarks_file),\n                \"target_landmarks\": str(target_landmarks_file),\n                \"free_polygons_floating\": str(free_polygons_floating_file),\n            }\n        )\n        project_file.write_text(project)\n        args: list[str | os.PathLike] = [\"WrapCmd.sh\", \"compute\", project_file]\n        if verbose:\n            args.append(\"--verbose\")\n        sp.run(args, check=True)\n        return io.load_polydata(output_file)\n</code></pre>"},{"location":"reference/liblaf/melon/external/#liblaf.melon.external.mesh_fix","title":"mesh_fix","text":"<pre><code>mesh_fix(\n    mesh: Any,\n    *,\n    check: bool = True,\n    verbose: bool = False,\n    joincomp: bool = False,\n    remove_smallest_components: bool = False,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/external/_mesh_fix.py</code> <pre><code>def mesh_fix(\n    mesh: Any,\n    *,\n    check: bool = True,\n    verbose: bool = False,\n    joincomp: bool = False,\n    remove_smallest_components: bool = False,\n) -&gt; pv.PolyData:\n    if grapes.has_module(\"pymeshfix\"):\n        result: pv.PolyData = _pymeshfix(\n            mesh,\n            verbose=verbose,\n            joincomp=joincomp,\n            remove_smallest_components=remove_smallest_components,\n        )\n    elif shutil.which(\"MeshFix\"):\n        result: pv.PolyData = _mesh_fix_exe(mesh, verbose=verbose)\n    else:\n        raise NotImplementedError\n    if check:\n        assert tri.is_volume(result)\n    mesh: pv.PolyData = io.as_polydata(mesh)\n    result.field_data.update(mesh.field_data)\n    return result\n</code></pre>"},{"location":"reference/liblaf/melon/external/#liblaf.melon.external.tetwild","title":"tetwild","text":"<pre><code>tetwild(\n    surface: Any,\n    *,\n    fix_winding: bool = True,\n    lr: float | None = None,\n    epsr: float | None = None,\n    level: int | None = None,\n    color: bool = False,\n    coarsen: bool = False,\n    csg: bool = False,\n    **kwargs,\n) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/external/_tetwild.py</code> <pre><code>def tetwild(\n    surface: Any,\n    *,\n    fix_winding: bool = True,\n    lr: float | None = None,\n    epsr: float | None = None,\n    level: int | None = None,\n    color: bool = False,\n    coarsen: bool = False,\n    csg: bool = False,\n    **kwargs,\n) -&gt; pv.UnstructuredGrid:\n    surface: pv.PolyData = copy_structure(surface)  # pyright: ignore[reportAssignmentType]\n    if shutil.which(\"fTetWild\"):\n        mesh: pv.UnstructuredGrid = _tetwild_exe(\n            surface,\n            lr=lr,\n            epsr=epsr,\n            level=level,\n            no_color=not color,\n            csg=csg,\n            coarsen=coarsen,\n            **kwargs,\n        )\n    else:\n        raise NotImplementedError\n    if fix_winding:\n        mesh = tetra.fix_winding(mesh)\n    return mesh\n</code></pre>"},{"location":"reference/liblaf/melon/external/wrap/","title":"wrap","text":""},{"location":"reference/liblaf/melon/external/wrap/#liblaf.melon.external.wrap","title":"liblaf.melon.external.wrap","text":"<p>Functions:</p> <ul> <li> <code>annotate_landmarks</code>             \u2013              </li> <li> <code>fast_wrapping</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/external/wrap/#liblaf.melon.external.wrap.annotate_landmarks","title":"annotate_landmarks","text":"<pre><code>annotate_landmarks(\n    left: Any,\n    right: Any,\n    *,\n    left_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    right_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n) -&gt; tuple[Float[ndarray, \"L 3\"], Float[ndarray, \"L 3\"]]\n</code></pre> Source code in <code>src/liblaf/melon/external/wrap/_annotate_landmarks.py</code> <pre><code>def annotate_landmarks(\n    left: Any,\n    right: Any,\n    *,\n    left_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    right_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n) -&gt; tuple[Float[np.ndarray, \"L 3\"], Float[np.ndarray, \"L 3\"]]:\n    if left_landmarks is None:\n        left_landmarks = np.zeros((0, 3))\n    if right_landmarks is None:\n        right_landmarks = np.zeros((0, 3))\n    with tempfile.TemporaryDirectory() as tmpdir_str:\n        tmpdir: Path = Path(tmpdir_str).absolute()\n        project_file: Path = tmpdir / \"annotate-landmarks.wrap\"\n        left_file: Path = tmpdir / \"left.obj\"\n        right_file: Path = tmpdir / \"right.obj\"\n        left_landmarks_file: Path = tmpdir / \"left.landmarks.json\"\n        right_landmarks_file: Path = tmpdir / \"right.landmarks.json\"\n        io.save(left_file, left)\n        io.save(right_file, right)\n        io.save_landmarks(left_landmarks_file, left_landmarks)\n        io.save_landmarks(right_landmarks_file, right_landmarks)\n        template: jinja2.Template = environment.get_template(\"annotate-landmarks.wrap\")\n        project: str = template.render(\n            {\n                \"left\": left_file,\n                \"right\": right_file,\n                \"left_landmarks\": left_landmarks_file,\n                \"right_landmarks\": right_landmarks_file,\n            }\n        )\n        project_file.write_text(project)\n        sp.run([\"Wrap.sh\", project_file], check=True)\n        left_landmarks = io.load_landmarks(left_landmarks_file)\n        right_landmarks = io.load_landmarks(right_landmarks_file)\n    return left_landmarks, right_landmarks\n</code></pre>"},{"location":"reference/liblaf/melon/external/wrap/#liblaf.melon.external.wrap.fast_wrapping","title":"fast_wrapping","text":"<pre><code>fast_wrapping(\n    source: Any,\n    target: Any,\n    *,\n    source_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    target_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    free_polygons_floating: Integer[ArrayLike, \" F\"]\n    | None = None,\n    verbose: bool = True,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/external/wrap/_fast_wrapping.py</code> <pre><code>def fast_wrapping(\n    source: Any,\n    target: Any,\n    *,\n    source_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    target_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    free_polygons_floating: Integer[ArrayLike, \" F\"] | None = None,\n    verbose: bool = True,\n) -&gt; pv.PolyData:\n    source_landmarks = source_landmarks if source_landmarks is not None else []\n    target_landmarks = target_landmarks if target_landmarks is not None else []\n    free_polygons_floating = (\n        free_polygons_floating if free_polygons_floating is not None else []\n    )\n    with tempfile.TemporaryDirectory(delete=False) as tmpdir_str:\n        tmpdir: Path = Path(tmpdir_str).absolute()\n        project_file: Path = tmpdir / \"fast-wrapping.wrap\"\n        source_file: Path = tmpdir / \"source.obj\"\n        target_file: Path = tmpdir / \"target.obj\"\n        output_file: Path = tmpdir / \"output.obj\"\n        source_landmarks_file: Path = tmpdir / \"source.landmarks.json\"\n        target_landmarks_file: Path = tmpdir / \"target.landmarks.json\"\n        free_polygons_floating_file: Path = tmpdir / \"free-polygons-floating.json\"\n        io.save(source_file, source)\n        io.save(target_file, target)\n        io.save_landmarks(source_landmarks_file, source_landmarks)\n        io.save_landmarks(target_landmarks_file, target_landmarks)\n        io.save_polygons(free_polygons_floating_file, free_polygons_floating)\n        template: jinja2.Template = environment.get_template(\"fast-wrapping.wrap\")\n        project: str = template.render(\n            {\n                \"source\": str(source_file),\n                \"target\": str(target_file),\n                \"output\": str(output_file),\n                \"source_landmarks\": str(source_landmarks_file),\n                \"target_landmarks\": str(target_landmarks_file),\n                \"free_polygons_floating\": str(free_polygons_floating_file),\n            }\n        )\n        project_file.write_text(project)\n        args: list[str | os.PathLike] = [\"WrapCmd.sh\", \"compute\", project_file]\n        if verbose:\n            args.append(\"--verbose\")\n        sp.run(args, check=True)\n        return io.load_polydata(output_file)\n</code></pre>"},{"location":"reference/liblaf/melon/io/","title":"io","text":""},{"location":"reference/liblaf/melon/io/#liblaf.melon.io","title":"liblaf.melon.io","text":"<p>Modules:</p> <ul> <li> <code>abc</code>           \u2013            </li> <li> <code>paraview</code>           \u2013            </li> <li> <code>pyvista</code>           \u2013            </li> <li> <code>trimesh</code>           \u2013            </li> <li> <code>wrap</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>PVDWriter</code>           \u2013            <p>.</p> </li> <li> <code>SeriesReader</code>           \u2013            </li> <li> <code>SeriesWriter</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_mesh</code>             \u2013              </li> <li> <code>get_landmarks_path</code>             \u2013              </li> <li> <code>get_polygons_path</code>             \u2013              </li> <li> <code>load_landmarks</code>             \u2013              </li> <li> <code>load_polygons</code>             \u2013              </li> <li> <code>save_landmarks</code>             \u2013              </li> <li> <code>save_polygons</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>as_pointset</code>               (<code>ConverterDispatcher[PointSet]</code>)           \u2013            </li> <li> <code>as_polydata</code>               (<code>ConverterDispatcher[PolyData]</code>)           \u2013            </li> <li> <code>as_structured_grid</code>               (<code>ConverterDispatcher[StructuredGrid]</code>)           \u2013            </li> <li> <code>as_trimesh</code>               (<code>ConverterDispatcher[Trimesh]</code>)           \u2013            </li> <li> <code>as_unstructured_grid</code>               (<code>ConverterDispatcher[UnstructuredGrid]</code>)           \u2013            </li> <li> <code>load_polydata</code>               (<code>ReaderDispatcher[PolyData]</code>)           \u2013            </li> <li> <code>load_structured_grid</code>               (<code>ReaderDispatcher[StructuredGrid]</code>)           \u2013            </li> <li> <code>load_trimesh</code>               (<code>ReaderDispatcher[Trimesh]</code>)           \u2013            </li> <li> <code>load_unstructured_grid</code>               (<code>ReaderDispatcher[UnstructuredGrid]</code>)           \u2013            </li> <li> <code>save</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.as_pointset","title":"as_pointset  <code>module-attribute</code>","text":"<pre><code>as_pointset: ConverterDispatcher[PointSet] = (\n    ConverterDispatcher(PointSet)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.as_polydata","title":"as_polydata  <code>module-attribute</code>","text":"<pre><code>as_polydata: ConverterDispatcher[PolyData] = (\n    ConverterDispatcher(PolyData)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.as_structured_grid","title":"as_structured_grid  <code>module-attribute</code>","text":"<pre><code>as_structured_grid: ConverterDispatcher[StructuredGrid] = (\n    ConverterDispatcher(StructuredGrid)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.as_trimesh","title":"as_trimesh  <code>module-attribute</code>","text":"<pre><code>as_trimesh: ConverterDispatcher[Trimesh] = (\n    ConverterDispatcher(Trimesh)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.as_unstructured_grid","title":"as_unstructured_grid  <code>module-attribute</code>","text":"<pre><code>as_unstructured_grid: ConverterDispatcher[\n    UnstructuredGrid\n] = ConverterDispatcher(UnstructuredGrid)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.load_polydata","title":"load_polydata  <code>module-attribute</code>","text":"<pre><code>load_polydata: ReaderDispatcher[PolyData] = (\n    ReaderDispatcher(PolyData)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.load_structured_grid","title":"load_structured_grid  <code>module-attribute</code>","text":"<pre><code>load_structured_grid: ReaderDispatcher[StructuredGrid] = (\n    ReaderDispatcher(StructuredGrid)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.load_trimesh","title":"load_trimesh  <code>module-attribute</code>","text":"<pre><code>load_trimesh: ReaderDispatcher[Trimesh] = ReaderDispatcher(\n    Trimesh\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.load_unstructured_grid","title":"load_unstructured_grid  <code>module-attribute</code>","text":"<pre><code>load_unstructured_grid: ReaderDispatcher[\n    UnstructuredGrid\n] = ReaderDispatcher(UnstructuredGrid)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.save","title":"save  <code>module-attribute</code>","text":"<pre><code>save = WriterDispatcher()\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.PVDWriter","title":"PVDWriter","text":"<p>.</p> References <p>[1]: ParaView/Data formats - KitwarePublic</p> <p>Parameters:</p> <ul> <li> <code>clear</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>file</code>               (<code>Path</code>, default:                   <code>PosixPath('animation.pvd')</code> )           \u2013            </li> <li> <code>fps</code>               (<code>float</code>, default:                   <code>30.0</code> )           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>datasets</code>               (<code>list[PVDDataSet]</code>)           \u2013            <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__attrs_post_init__</code>             \u2013              </li> <li> <code>append</code>             \u2013              </li> <li> <code>end</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.PVDWriter.clear","title":"clear  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clear: bool = field(default=False, kw_only=True)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.PVDWriter.datasets","title":"datasets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>datasets: list[PVDDataSet] = field(init=False, factory=list)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.PVDWriter.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: Path = field(\n    default=Path(\"animation.pvd\"), converter=Path\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.PVDWriter.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.PVDWriter.fps","title":"fps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fps: float = field(default=30.0, kw_only=True)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.PVDWriter.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.PVDWriter.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/_pvd_writer.py</code> <pre><code>def __attrs_post_init__(self) -&gt; None:\n    if self.clear:\n        shutil.rmtree(self.folder, ignore_errors=True)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.PVDWriter.append","title":"append","text":"<pre><code>append(\n    dataset: Any,\n    timestep: float | None = None,\n    *,\n    ext: str,\n    part: int = 0,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/_pvd_writer.py</code> <pre><code>def append(\n    self, dataset: Any, timestep: float | None = None, *, ext: str, part: int = 0\n) -&gt; None:\n    if timestep is None:\n        timestep = (\n            self.datasets[-1].timestep + (1 / self.fps) if self.datasets else 0\n        )\n    frame_id: int = len(self.datasets)\n    filename: str = f\"{self.name}_{frame_id:06d}\"\n    filename += ext\n    filepath: Path = self.folder / filename\n    save(filepath, dataset)\n    self.datasets.append(PVDDataSet(timestep=timestep, part=part, file=filepath))\n    self.end()\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.PVDWriter.end","title":"end","text":"<pre><code>end() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/_pvd_writer.py</code> <pre><code>def end(self) -&gt; None:\n    root = ElementTree.Element(\n        \"VTKFile\", type=\"Collection\", version=\"0.1\", byte_order=\"LittleEndian\"\n    )\n    collection: ElementTree.Element = ElementTree.SubElement(root, \"Collection\")\n    root_dir: Path = self.file.absolute().parent\n    for dataset in self.datasets:\n        elem: ElementTree.Element = ElementTree.SubElement(collection, \"DataSet\")\n        elem.set(\"timestep\", str(dataset.timestep))\n        elem.set(\"part\", str(dataset.part))\n        elem.set(\"file\", dataset.file.absolute().relative_to(root_dir).as_posix())\n    tree = ElementTree.ElementTree(root)\n    ElementTree.indent(tree, space=\"  \")\n    self.file.parent.mkdir(parents=True, exist_ok=True)\n    tree.write(self.file, xml_declaration=True)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesReader","title":"SeriesReader","text":"<pre><code>SeriesReader(file: PathLike, loader: Callable[[Path], T])\n</code></pre> <p>               Bases: <code>Sequence[T]</code></p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>loader</code>               (<code>Callable[list, T]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>folder</code>               (<code>Path</code>)           \u2013            </li> <li> <code>loader</code>               (<code>Callable[[Path], T]</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>time_values</code>               (<code>list[float]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>def __init__(self, file: PathLike, loader: Callable[[Path], T]) -&gt; None:\n    file = Path(file)\n    self.__attrs_init__(file=file, loader=loader)  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesReader.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesReader.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesReader.loader","title":"loader  <code>instance-attribute</code>","text":"<pre><code>loader: Callable[[Path], T]\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesReader.series","title":"series  <code>cached</code> <code>property</code>","text":"<pre><code>series: Series\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesReader.time_values","title":"time_values  <code>property</code>","text":"<pre><code>time_values: list[float]\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesReader.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; T\n</code></pre><pre><code>__getitem__(index: slice) -&gt; Sequence[T]\n</code></pre> <pre><code>__getitem__(index: int | slice) -&gt; T | Sequence[T]\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>@override\ndef __getitem__(self, index: int | slice) -&gt; T | Sequence[T]:\n    __tracebackhide__ = True\n    files: File | list[File] = self.series.files[index]\n    if isinstance(files, File):\n        return self.loader(self.folder / files.name)\n    return [self.loader(self.folder / f.name) for f in files]\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesReader.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    return len(self.series.files)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter","title":"SeriesWriter","text":"<pre><code>SeriesWriter(\n    file: PathLike,\n    /,\n    *,\n    clear: bool = False,\n    fps: float = 30.0,\n    step: float | None = None,\n)\n</code></pre> <p>               Bases: <code>Sequence[File]</code>, <code>AbstractContextManager</code></p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>step</code>               (<code>float</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__enter__</code>             \u2013              </li> <li> <code>__exit__</code>             \u2013              </li> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>append</code>             \u2013              </li> <li> <code>end</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>start</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>ext</code>               (<code>str</code>)           \u2013            </li> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>folder</code>               (<code>Path</code>)           \u2013            </li> <li> <code>fps</code>               (<code>float</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>step</code>               (<code>float</code>)           \u2013            </li> <li> <code>time</code>               (<code>float</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __init__(\n    self,\n    file: PathLike,\n    /,\n    *,\n    clear: bool = False,\n    fps: float = 30.0,\n    step: float | None = None,\n) -&gt; None:\n    if step is None:\n        step = 1.0 / fps\n    self.__attrs_init__(file=Path(file), series=Series(), step=step)  # pyright: ignore[reportAttributeAccessIssue]\n    if clear:\n        shutil.rmtree(self.folder, ignore_errors=True)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.ext","title":"ext  <code>property</code>","text":"<pre><code>ext: str\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.fps","title":"fps  <code>property</code>","text":"<pre><code>fps: float\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.series","title":"series  <code>instance-attribute</code>","text":"<pre><code>series: Series\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step: float\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.time","title":"time  <code>property</code>","text":"<pre><code>time: float\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.__exit__","title":"__exit__","text":"<pre><code>__exit__(\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: types.TracebackType | None,\n) -&gt; None:\n    self.end()\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; File\n</code></pre><pre><code>__getitem__(index: slice) -&gt; list[File]\n</code></pre> <pre><code>__getitem__(index: int | slice) -&gt; File | list[File]\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __getitem__(self, index: int | slice) -&gt; File | list[File]:\n    return self.series.files[index]\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.series.files)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.append","title":"append","text":"<pre><code>append(\n    data: Any,\n    *,\n    time: float | None = None,\n    timestep: float | None = None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def append(\n    self, data: Any, *, time: float | None = None, timestep: float | None = None\n) -&gt; None:\n    __tracebackhide__ = True\n    filename: str = f\"{self.name}_{len(self):06d}{self.ext}\"\n    filepath: Path = self.folder / filename\n    save(filepath, data)\n    if time is None:\n        if timestep is None:\n            timestep = self.step\n        time = self.time + timestep\n    self.series.files.append(\n        File(name=filepath.relative_to(self.file.parent).as_posix(), time=time)\n    )\n    self.save()\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.end","title":"end","text":"<pre><code>end() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def end(self) -&gt; None:\n    self.save()\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.save","title":"save","text":"<pre><code>save() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def save(self) -&gt; None:\n    grapes.save(\n        self.file, self.series, force_ext=\".json\", pydantic={\"by_alias\": True}\n    )\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.SeriesWriter.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def start(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.as_mesh","title":"as_mesh","text":"<pre><code>as_mesh(mesh: Any) -&gt; PolyData | UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/_convert.py</code> <pre><code>def as_mesh(mesh: Any) -&gt; pv.PolyData | pv.UnstructuredGrid:\n    try:\n        return as_polydata(mesh)\n    except UnsupportedConverterError:\n        pass\n    return as_unstructured_grid(mesh)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.get_landmarks_path","title":"get_landmarks_path","text":"<pre><code>get_landmarks_path(path: str | PathLike[str]) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_utils.py</code> <pre><code>def get_landmarks_path(path: str | os.PathLike[str]) -&gt; Path:\n    path: Path = Path(path)\n    if path.suffix != \".json\":\n        return path.with_suffix(\".landmarks.json\")\n    return path\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.get_polygons_path","title":"get_polygons_path","text":"<pre><code>get_polygons_path(path: str | PathLike[str]) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_utils.py</code> <pre><code>def get_polygons_path(path: str | os.PathLike[str]) -&gt; Path:\n    path: Path = Path(path)\n    if path.suffix != \".json\":\n        return path.with_suffix(\".polygons.json\")\n    return path\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.load_landmarks","title":"load_landmarks","text":"<pre><code>load_landmarks(\n    path: str | PathLike[str],\n) -&gt; Float[ndarray, \"N 3\"]\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_reader.py</code> <pre><code>def load_landmarks(path: str | os.PathLike[str]) -&gt; Float[np.ndarray, \"N 3\"]:\n    path: Path = get_landmarks_path(path)\n    if not path.exists():\n        return np.empty((0, 3), dtype=float)\n    data: list[dict[str, float]] = grapes.load(path)\n    return np.asarray([[p[\"x\"], p[\"y\"], p[\"z\"]] for p in data])\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.load_polygons","title":"load_polygons","text":"<pre><code>load_polygons(path: PathLike) -&gt; Integer[ndarray, ' N']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_reader.py</code> <pre><code>def load_polygons(path: PathLike) -&gt; Integer[np.ndarray, \" N\"]:\n    path: Path = get_polygons_path(path)\n    data: list[int] = grapes.load(path)\n    return np.asarray(data)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.save_landmarks","title":"save_landmarks","text":"<pre><code>save_landmarks(\n    path: str | PathLike[str],\n    points: Float[ArrayLike, \"N 3\"],\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_writer.py</code> <pre><code>def save_landmarks(\n    path: str | os.PathLike[str], points: Float[ArrayLike, \"N 3\"]\n) -&gt; None:\n    path: Path = get_landmarks_path(path)\n    points: Float[np.ndarray, \"N 3\"] = np.asarray(points)\n    data: list[dict[str, float]] = [\n        {\"x\": p[0], \"y\": p[1], \"z\": p[2]} for p in points.tolist()\n    ]\n    grapes.save(path, data)\n</code></pre>"},{"location":"reference/liblaf/melon/io/#liblaf.melon.io.save_polygons","title":"save_polygons","text":"<pre><code>save_polygons(\n    path: str | PathLike[str],\n    polygons: Integer[ArrayLike, \" N\"],\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_writer.py</code> <pre><code>def save_polygons(\n    path: str | os.PathLike[str], polygons: Integer[ArrayLike, \" N\"]\n) -&gt; None:\n    path: Path = get_polygons_path(path)\n    polygons = np.asarray(polygons)\n    grapes.save(path, polygons.tolist())\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/","title":"abc","text":""},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc","title":"liblaf.melon.io.abc","text":"<p>Classes:</p> <ul> <li> <code>ConverterDispatcher</code>           \u2013            </li> <li> <code>Reader</code>           \u2013            </li> <li> <code>ReaderDispatcher</code>           \u2013            </li> <li> <code>UnsupportedConverterError</code>           \u2013            </li> <li> <code>UnsupportedReaderError</code>           \u2013            </li> <li> <code>UnsupportedWriterError</code>           \u2013            </li> <li> <code>Writer</code>           \u2013            </li> <li> <code>WriterDispatcher</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.ConverterDispatcher","title":"ConverterDispatcher","text":"<pre><code>ConverterDispatcher(to_type: type[T])\n</code></pre> <p>Parameters:</p> <ul> <li> <code>to_type</code>               (<code>type[T]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dispatch</code>               (<code>SingleDispatchCallable[T]</code>)           \u2013            </li> <li> <code>to_type</code>               (<code>type[T]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/abc/_converter.py</code> <pre><code>def __init__(self, to_type: type[T]) -&gt; None:\n    @functools.singledispatch\n    def dispatch(obj: Any, /, **kwargs) -&gt; T:  # noqa: ARG001\n        raise UnsupportedConverterError(obj, to_type)\n\n    self.__attrs_init__(to_type=to_type, dispatch=dispatch)  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.ConverterDispatcher.dispatch","title":"dispatch  <code>instance-attribute</code>","text":"<pre><code>dispatch: SingleDispatchCallable[T]\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.ConverterDispatcher.to_type","title":"to_type  <code>instance-attribute</code>","text":"<pre><code>to_type: type[T]\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.ConverterDispatcher.__call__","title":"__call__","text":"<pre><code>__call__(obj: Any, /, **kwargs) -&gt; T\n</code></pre> Source code in <code>src/liblaf/melon/io/abc/_converter.py</code> <pre><code>def __call__(self, obj: Any, /, **kwargs) -&gt; T:\n    if isinstance(obj, self.to_type):\n        return obj\n    result: T = self.dispatch(obj, **kwargs)\n    # logger.trace(f\"Converted {type(obj)} to {type(result)}.\")\n    return result\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.ConverterDispatcher.register","title":"register","text":"<pre><code>register(\n    cls: RegType,\n) -&gt; Callable[[Callable[..., T]], Callable[..., T]]\n</code></pre> Source code in <code>src/liblaf/melon/io/abc/_converter.py</code> <pre><code>def register(self, cls: RegType) -&gt; Callable[[Callable[..., T]], Callable[..., T]]:\n    return self.dispatch.register(cls)\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.Reader","title":"Reader","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.Reader.__call__","title":"__call__","text":"<pre><code>__call__(path: Path, /, **kwargs) -&gt; T\n</code></pre> Source code in <code>src/liblaf/melon/io/abc/_reader.py</code> <pre><code>def __call__(self, path: Path, /, **kwargs) -&gt; T: ...\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.ReaderDispatcher","title":"ReaderDispatcher","text":"<p>Parameters:</p> <ul> <li> <code>to_type</code>               (<code>type[T]</code>)           \u2013            </li> <li> <code>registry</code>               (<code>dict[str, Reader[T]]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>registry</code>               (<code>dict[str, Reader[T]]</code>)           \u2013            </li> <li> <code>to_type</code>               (<code>type[T]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.ReaderDispatcher.registry","title":"registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>registry: dict[str, Reader[T]] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.ReaderDispatcher.to_type","title":"to_type  <code>instance-attribute</code>","text":"<pre><code>to_type: type[T]\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.ReaderDispatcher.__call__","title":"__call__","text":"<pre><code>__call__(path: PathLike, /, **kwargs) -&gt; T\n</code></pre> Source code in <code>src/liblaf/melon/io/abc/_reader.py</code> <pre><code>def __call__(self, path: PathLike, /, **kwargs) -&gt; T:\n    __tracebackhide__ = True\n    path = Path(path)\n    reader: Reader[T] | None = self.registry.get(path.suffix)\n    if reader is None:\n        raise UnsupportedReaderError(path, self.to_type)\n    obj: T = reader(path, **kwargs)\n    logger.debug(f\"Loaded '{path}' as {type(obj)}.\")\n    return obj\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.ReaderDispatcher.register","title":"register","text":"<pre><code>register(\n    *suffixes: str,\n) -&gt; Callable[[Reader[T]], Reader[T]]\n</code></pre> Source code in <code>src/liblaf/melon/io/abc/_reader.py</code> <pre><code>def register(self, *suffixes: str) -&gt; Callable[[Reader[T]], Reader[T]]:\n    def wrapper(reader: Reader[T]) -&gt; Reader[T]:\n        for s in suffixes:\n            self.registry[s] = reader\n        return reader\n\n    return wrapper\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedConverterError","title":"UnsupportedConverterError","text":"<pre><code>UnsupportedConverterError(obj_or_cls: Any, to_type: type)\n</code></pre> <p>               Bases: <code>ValueError</code></p> <p>Parameters:</p> <ul> <li> <code>from_type</code>               (<code>type</code>)           \u2013            </li> <li> <code>to_type</code>               (<code>type</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>from_type</code>               (<code>type</code>)           \u2013            </li> <li> <code>to_type</code>               (<code>type</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/abc/_converter.py</code> <pre><code>def __init__(self, obj_or_cls: Any, to_type: type, /) -&gt; None:\n    from_type: type = (\n        obj_or_cls if isinstance(obj_or_cls, type) else type(obj_or_cls)\n    )\n    self.__attrs_init__(from_type=from_type, to_type=to_type)  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedConverterError.from_type","title":"from_type  <code>instance-attribute</code>","text":"<pre><code>from_type: type\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedConverterError.to_type","title":"to_type  <code>instance-attribute</code>","text":"<pre><code>to_type: type\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedConverterError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/liblaf/melon/io/abc/_converter.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"Cannot convert {self.from_type} to {self.to_type}.\"\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedReaderError","title":"UnsupportedReaderError","text":"<p>               Bases: <code>ValueError</code></p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>to_type</code>               (<code>type</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> <li> <code>to_type</code>               (<code>type</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedReaderError.path","title":"path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>path: Path = field(converter=Path)\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedReaderError.to_type","title":"to_type  <code>instance-attribute</code>","text":"<pre><code>to_type: type\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedReaderError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/liblaf/melon/io/abc/_reader.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"Cannot load '{self.path}' as {self.to_type}.\"\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedWriterError","title":"UnsupportedWriterError","text":"<p>               Bases: <code>ValueError</code></p> <p>Parameters:</p> <ul> <li> <code>from_type</code>               (<code>type</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>from_type</code>               (<code>type</code>)           \u2013            </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedWriterError.from_type","title":"from_type  <code>instance-attribute</code>","text":"<pre><code>from_type: type\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedWriterError.path","title":"path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>path: Path = field(converter=Path)\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.UnsupportedWriterError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/liblaf/melon/io/abc/_writer.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"Cannot save {self.from_type} to '{self.path}'.\"\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.Writer","title":"Writer","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.Writer.__call__","title":"__call__","text":"<pre><code>__call__(path: Path, obj: Any, /, **kwargs) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/abc/_writer.py</code> <pre><code>def __call__(self, path: Path, obj: Any, /, **kwargs) -&gt; None: ...\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.WriterDispatcher","title":"WriterDispatcher","text":"<p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>writers</code>               (<code>dict[str, SingleDispatchCallable[None]]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.WriterDispatcher.writers","title":"writers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>writers: dict[str, SingleDispatchCallable[None]] = field(\n    factory=lambda: defaultdict(\n        lambda: singledispatch(_dummy)\n    )\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.WriterDispatcher.__call__","title":"__call__","text":"<pre><code>__call__(path: PathLike, obj: Any, /, **kwargs) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/abc/_writer.py</code> <pre><code>def __call__(self, path: PathLike, obj: Any, /, **kwargs) -&gt; None:\n    __tracebackhide__ = True\n    path = Path(path)\n    writer: SingleDispatchCallable[None] | None = self.writers.get(path.suffix)\n    if writer is None:\n        raise UnsupportedWriterError(type(obj), path)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    impl: Writer = writer.dispatch(type(obj))\n    if impl is _dummy:\n        raise UnsupportedWriterError(type(obj), path)\n    impl(path, obj, **kwargs)\n    logger.debug(f\"Saved {type(obj)} to '{path}'.\")\n</code></pre>"},{"location":"reference/liblaf/melon/io/abc/#liblaf.melon.io.abc.WriterDispatcher.register","title":"register","text":"<pre><code>register(\n    cls: RegType, suffix: str | Iterable[str]\n) -&gt; Callable[[Writer], Writer]\n</code></pre> Source code in <code>src/liblaf/melon/io/abc/_writer.py</code> <pre><code>def register(\n    self, cls: RegType, suffix: str | Iterable[str]\n) -&gt; Callable[[Writer], Writer]:\n    def wrapper(func: Writer) -&gt; Writer:\n        for s in grapes.as_iterable(suffix):\n            self.writers[s].register(cls)(func)\n        return func\n\n    return wrapper\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/","title":"paraview","text":""},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview","title":"liblaf.melon.io.paraview","text":"<p>Modules:</p> <ul> <li> <code>series</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>PVDWriter</code>           \u2013            <p>.</p> </li> <li> <code>SeriesReader</code>           \u2013            </li> <li> <code>SeriesWriter</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.PVDWriter","title":"PVDWriter","text":"<p>.</p> References <p>[1]: ParaView/Data formats - KitwarePublic</p> <p>Parameters:</p> <ul> <li> <code>clear</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>file</code>               (<code>Path</code>, default:                   <code>PosixPath('animation.pvd')</code> )           \u2013            </li> <li> <code>fps</code>               (<code>float</code>, default:                   <code>30.0</code> )           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>datasets</code>               (<code>list[PVDDataSet]</code>)           \u2013            <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__attrs_post_init__</code>             \u2013              </li> <li> <code>append</code>             \u2013              </li> <li> <code>end</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.PVDWriter.clear","title":"clear  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clear: bool = field(default=False, kw_only=True)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.PVDWriter.datasets","title":"datasets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>datasets: list[PVDDataSet] = field(init=False, factory=list)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.PVDWriter.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: Path = field(\n    default=Path(\"animation.pvd\"), converter=Path\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.PVDWriter.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.PVDWriter.fps","title":"fps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fps: float = field(default=30.0, kw_only=True)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.PVDWriter.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.PVDWriter.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/_pvd_writer.py</code> <pre><code>def __attrs_post_init__(self) -&gt; None:\n    if self.clear:\n        shutil.rmtree(self.folder, ignore_errors=True)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.PVDWriter.append","title":"append","text":"<pre><code>append(\n    dataset: Any,\n    timestep: float | None = None,\n    *,\n    ext: str,\n    part: int = 0,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/_pvd_writer.py</code> <pre><code>def append(\n    self, dataset: Any, timestep: float | None = None, *, ext: str, part: int = 0\n) -&gt; None:\n    if timestep is None:\n        timestep = (\n            self.datasets[-1].timestep + (1 / self.fps) if self.datasets else 0\n        )\n    frame_id: int = len(self.datasets)\n    filename: str = f\"{self.name}_{frame_id:06d}\"\n    filename += ext\n    filepath: Path = self.folder / filename\n    save(filepath, dataset)\n    self.datasets.append(PVDDataSet(timestep=timestep, part=part, file=filepath))\n    self.end()\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.PVDWriter.end","title":"end","text":"<pre><code>end() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/_pvd_writer.py</code> <pre><code>def end(self) -&gt; None:\n    root = ElementTree.Element(\n        \"VTKFile\", type=\"Collection\", version=\"0.1\", byte_order=\"LittleEndian\"\n    )\n    collection: ElementTree.Element = ElementTree.SubElement(root, \"Collection\")\n    root_dir: Path = self.file.absolute().parent\n    for dataset in self.datasets:\n        elem: ElementTree.Element = ElementTree.SubElement(collection, \"DataSet\")\n        elem.set(\"timestep\", str(dataset.timestep))\n        elem.set(\"part\", str(dataset.part))\n        elem.set(\"file\", dataset.file.absolute().relative_to(root_dir).as_posix())\n    tree = ElementTree.ElementTree(root)\n    ElementTree.indent(tree, space=\"  \")\n    self.file.parent.mkdir(parents=True, exist_ok=True)\n    tree.write(self.file, xml_declaration=True)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesReader","title":"SeriesReader","text":"<pre><code>SeriesReader(file: PathLike, loader: Callable[[Path], T])\n</code></pre> <p>               Bases: <code>Sequence[T]</code></p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>loader</code>               (<code>Callable[list, T]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>folder</code>               (<code>Path</code>)           \u2013            </li> <li> <code>loader</code>               (<code>Callable[[Path], T]</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>time_values</code>               (<code>list[float]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>def __init__(self, file: PathLike, loader: Callable[[Path], T]) -&gt; None:\n    file = Path(file)\n    self.__attrs_init__(file=file, loader=loader)  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesReader.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesReader.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesReader.loader","title":"loader  <code>instance-attribute</code>","text":"<pre><code>loader: Callable[[Path], T]\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesReader.series","title":"series  <code>cached</code> <code>property</code>","text":"<pre><code>series: Series\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesReader.time_values","title":"time_values  <code>property</code>","text":"<pre><code>time_values: list[float]\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesReader.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; T\n</code></pre><pre><code>__getitem__(index: slice) -&gt; Sequence[T]\n</code></pre> <pre><code>__getitem__(index: int | slice) -&gt; T | Sequence[T]\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>@override\ndef __getitem__(self, index: int | slice) -&gt; T | Sequence[T]:\n    __tracebackhide__ = True\n    files: File | list[File] = self.series.files[index]\n    if isinstance(files, File):\n        return self.loader(self.folder / files.name)\n    return [self.loader(self.folder / f.name) for f in files]\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesReader.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    return len(self.series.files)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter","title":"SeriesWriter","text":"<pre><code>SeriesWriter(\n    file: PathLike,\n    /,\n    *,\n    clear: bool = False,\n    fps: float = 30.0,\n    step: float | None = None,\n)\n</code></pre> <p>               Bases: <code>Sequence[File]</code>, <code>AbstractContextManager</code></p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>step</code>               (<code>float</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__enter__</code>             \u2013              </li> <li> <code>__exit__</code>             \u2013              </li> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>append</code>             \u2013              </li> <li> <code>end</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>start</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>ext</code>               (<code>str</code>)           \u2013            </li> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>folder</code>               (<code>Path</code>)           \u2013            </li> <li> <code>fps</code>               (<code>float</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>step</code>               (<code>float</code>)           \u2013            </li> <li> <code>time</code>               (<code>float</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __init__(\n    self,\n    file: PathLike,\n    /,\n    *,\n    clear: bool = False,\n    fps: float = 30.0,\n    step: float | None = None,\n) -&gt; None:\n    if step is None:\n        step = 1.0 / fps\n    self.__attrs_init__(file=Path(file), series=Series(), step=step)  # pyright: ignore[reportAttributeAccessIssue]\n    if clear:\n        shutil.rmtree(self.folder, ignore_errors=True)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.ext","title":"ext  <code>property</code>","text":"<pre><code>ext: str\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.fps","title":"fps  <code>property</code>","text":"<pre><code>fps: float\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.series","title":"series  <code>instance-attribute</code>","text":"<pre><code>series: Series\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step: float\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.time","title":"time  <code>property</code>","text":"<pre><code>time: float\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.__exit__","title":"__exit__","text":"<pre><code>__exit__(\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: types.TracebackType | None,\n) -&gt; None:\n    self.end()\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; File\n</code></pre><pre><code>__getitem__(index: slice) -&gt; list[File]\n</code></pre> <pre><code>__getitem__(index: int | slice) -&gt; File | list[File]\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __getitem__(self, index: int | slice) -&gt; File | list[File]:\n    return self.series.files[index]\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.series.files)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.append","title":"append","text":"<pre><code>append(\n    data: Any,\n    *,\n    time: float | None = None,\n    timestep: float | None = None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def append(\n    self, data: Any, *, time: float | None = None, timestep: float | None = None\n) -&gt; None:\n    __tracebackhide__ = True\n    filename: str = f\"{self.name}_{len(self):06d}{self.ext}\"\n    filepath: Path = self.folder / filename\n    save(filepath, data)\n    if time is None:\n        if timestep is None:\n            timestep = self.step\n        time = self.time + timestep\n    self.series.files.append(\n        File(name=filepath.relative_to(self.file.parent).as_posix(), time=time)\n    )\n    self.save()\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.end","title":"end","text":"<pre><code>end() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def end(self) -&gt; None:\n    self.save()\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.save","title":"save","text":"<pre><code>save() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def save(self) -&gt; None:\n    grapes.save(\n        self.file, self.series, force_ext=\".json\", pydantic={\"by_alias\": True}\n    )\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/#liblaf.melon.io.paraview.SeriesWriter.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def start(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/","title":"series","text":""},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series","title":"liblaf.melon.io.paraview.series","text":"<p>Classes:</p> <ul> <li> <code>File</code>           \u2013            </li> <li> <code>Series</code>           \u2013            </li> <li> <code>SeriesReader</code>           \u2013            </li> <li> <code>SeriesWriter</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.File","title":"File  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>time</code>               (<code>float</code>)           \u2013            </li> </ul> Show JSON schema: <pre><code>{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"Name\",\n      \"type\": \"string\"\n    },\n    \"time\": {\n      \"title\": \"Time\",\n      \"type\": \"number\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"time\"\n  ],\n  \"title\": \"File\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>time</code>                 (<code>float</code>)             </li> </ul>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.File.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.File.time","title":"time  <code>pydantic-field</code>","text":"<pre><code>time: float\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.Series","title":"Series  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> <ul> <li> <code>file_series_version</code>               (<code>Literal['1.0']</code>, default:                   <code>'1.0'</code> )           \u2013            </li> <li> <code>files</code>               (<code>list[File]</code>, default:                   <code>[]</code> )           \u2013            </li> </ul> Show JSON schema: <pre><code>{\n  \"$defs\": {\n    \"File\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"time\": {\n          \"title\": \"Time\",\n          \"type\": \"number\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"time\"\n      ],\n      \"title\": \"File\",\n      \"type\": \"object\"\n    }\n  },\n  \"properties\": {\n    \"file-series-version\": {\n      \"const\": \"1.0\",\n      \"default\": \"1.0\",\n      \"title\": \"File-Series-Version\",\n      \"type\": \"string\"\n    },\n    \"files\": {\n      \"default\": [],\n      \"items\": {\n        \"$ref\": \"#/$defs/File\"\n      },\n      \"title\": \"Files\",\n      \"type\": \"array\"\n    }\n  },\n  \"title\": \"Series\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Config:</p> <ul> <li><code>alias_generator</code>: <code>snake_to_kebab</code></li> </ul> <p>Fields:</p> <ul> <li> <code>file_series_version</code>                 (<code>Literal['1.0']</code>)             </li> <li> <code>files</code>                 (<code>list[File]</code>)             </li> </ul>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.Series.file_series_version","title":"file_series_version  <code>pydantic-field</code>","text":"<pre><code>file_series_version: Literal['1.0'] = '1.0'\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.Series.files","title":"files  <code>pydantic-field</code>","text":"<pre><code>files: list[File] = []\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.Series.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(alias_generator=snake_to_kebab)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesReader","title":"SeriesReader","text":"<pre><code>SeriesReader(file: PathLike, loader: Callable[[Path], T])\n</code></pre> <p>               Bases: <code>Sequence[T]</code></p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>loader</code>               (<code>Callable[list, T]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>folder</code>               (<code>Path</code>)           \u2013            </li> <li> <code>loader</code>               (<code>Callable[[Path], T]</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>time_values</code>               (<code>list[float]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>def __init__(self, file: PathLike, loader: Callable[[Path], T]) -&gt; None:\n    file = Path(file)\n    self.__attrs_init__(file=file, loader=loader)  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesReader.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesReader.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesReader.loader","title":"loader  <code>instance-attribute</code>","text":"<pre><code>loader: Callable[[Path], T]\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesReader.series","title":"series  <code>cached</code> <code>property</code>","text":"<pre><code>series: Series\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesReader.time_values","title":"time_values  <code>property</code>","text":"<pre><code>time_values: list[float]\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesReader.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; T\n</code></pre><pre><code>__getitem__(index: slice) -&gt; Sequence[T]\n</code></pre> <pre><code>__getitem__(index: int | slice) -&gt; T | Sequence[T]\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>@override\ndef __getitem__(self, index: int | slice) -&gt; T | Sequence[T]:\n    __tracebackhide__ = True\n    files: File | list[File] = self.series.files[index]\n    if isinstance(files, File):\n        return self.loader(self.folder / files.name)\n    return [self.loader(self.folder / f.name) for f in files]\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesReader.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_reader.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    return len(self.series.files)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter","title":"SeriesWriter","text":"<pre><code>SeriesWriter(\n    file: PathLike,\n    /,\n    *,\n    clear: bool = False,\n    fps: float = 30.0,\n    step: float | None = None,\n)\n</code></pre> <p>               Bases: <code>Sequence[File]</code>, <code>AbstractContextManager</code></p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>step</code>               (<code>float</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__enter__</code>             \u2013              </li> <li> <code>__exit__</code>             \u2013              </li> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>append</code>             \u2013              </li> <li> <code>end</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>start</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>ext</code>               (<code>str</code>)           \u2013            </li> <li> <code>file</code>               (<code>Path</code>)           \u2013            </li> <li> <code>folder</code>               (<code>Path</code>)           \u2013            </li> <li> <code>fps</code>               (<code>float</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>series</code>               (<code>Series</code>)           \u2013            </li> <li> <code>step</code>               (<code>float</code>)           \u2013            </li> <li> <code>time</code>               (<code>float</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __init__(\n    self,\n    file: PathLike,\n    /,\n    *,\n    clear: bool = False,\n    fps: float = 30.0,\n    step: float | None = None,\n) -&gt; None:\n    if step is None:\n        step = 1.0 / fps\n    self.__attrs_init__(file=Path(file), series=Series(), step=step)  # pyright: ignore[reportAttributeAccessIssue]\n    if clear:\n        shutil.rmtree(self.folder, ignore_errors=True)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.ext","title":"ext  <code>property</code>","text":"<pre><code>ext: str\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.fps","title":"fps  <code>property</code>","text":"<pre><code>fps: float\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.series","title":"series  <code>instance-attribute</code>","text":"<pre><code>series: Series\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step: float\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.time","title":"time  <code>property</code>","text":"<pre><code>time: float\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.__exit__","title":"__exit__","text":"<pre><code>__exit__(\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: types.TracebackType | None,\n) -&gt; None:\n    self.end()\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; File\n</code></pre><pre><code>__getitem__(index: slice) -&gt; list[File]\n</code></pre> <pre><code>__getitem__(index: int | slice) -&gt; File | list[File]\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __getitem__(self, index: int | slice) -&gt; File | list[File]:\n    return self.series.files[index]\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.series.files)\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.append","title":"append","text":"<pre><code>append(\n    data: Any,\n    *,\n    time: float | None = None,\n    timestep: float | None = None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def append(\n    self, data: Any, *, time: float | None = None, timestep: float | None = None\n) -&gt; None:\n    __tracebackhide__ = True\n    filename: str = f\"{self.name}_{len(self):06d}{self.ext}\"\n    filepath: Path = self.folder / filename\n    save(filepath, data)\n    if time is None:\n        if timestep is None:\n            timestep = self.step\n        time = self.time + timestep\n    self.series.files.append(\n        File(name=filepath.relative_to(self.file.parent).as_posix(), time=time)\n    )\n    self.save()\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.end","title":"end","text":"<pre><code>end() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def end(self) -&gt; None:\n    self.save()\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.save","title":"save","text":"<pre><code>save() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def save(self) -&gt; None:\n    grapes.save(\n        self.file, self.series, force_ext=\".json\", pydantic={\"by_alias\": True}\n    )\n</code></pre>"},{"location":"reference/liblaf/melon/io/paraview/series/#liblaf.melon.io.paraview.series.SeriesWriter.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/paraview/series/_writer.py</code> <pre><code>def start(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/","title":"pyvista","text":""},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista","title":"liblaf.melon.io.pyvista","text":"<p>Modules:</p> <ul> <li> <code>pointset</code>           \u2013            </li> <li> <code>polydata</code>           \u2013            </li> <li> <code>structured_grid</code>           \u2013            </li> <li> <code>unstructured_grid</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_mesh</code>             \u2013              </li> <li> <code>save_polydata</code>             \u2013              </li> <li> <code>save_polydata_obj</code>             \u2013              </li> <li> <code>save_structured_grid</code>             \u2013              </li> <li> <code>save_unstructured_grid</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>as_pointset</code>               (<code>ConverterDispatcher[PointSet]</code>)           \u2013            </li> <li> <code>as_polydata</code>               (<code>ConverterDispatcher[PolyData]</code>)           \u2013            </li> <li> <code>as_structured_grid</code>               (<code>ConverterDispatcher[StructuredGrid]</code>)           \u2013            </li> <li> <code>as_unstructured_grid</code>               (<code>ConverterDispatcher[UnstructuredGrid]</code>)           \u2013            </li> <li> <code>load_polydata</code>               (<code>ReaderDispatcher[PolyData]</code>)           \u2013            </li> <li> <code>load_structured_grid</code>               (<code>ReaderDispatcher[StructuredGrid]</code>)           \u2013            </li> <li> <code>load_unstructured_grid</code>               (<code>ReaderDispatcher[UnstructuredGrid]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.as_pointset","title":"as_pointset  <code>module-attribute</code>","text":"<pre><code>as_pointset: ConverterDispatcher[PointSet] = (\n    ConverterDispatcher(PointSet)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.as_polydata","title":"as_polydata  <code>module-attribute</code>","text":"<pre><code>as_polydata: ConverterDispatcher[PolyData] = (\n    ConverterDispatcher(PolyData)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.as_structured_grid","title":"as_structured_grid  <code>module-attribute</code>","text":"<pre><code>as_structured_grid: ConverterDispatcher[StructuredGrid] = (\n    ConverterDispatcher(StructuredGrid)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.as_unstructured_grid","title":"as_unstructured_grid  <code>module-attribute</code>","text":"<pre><code>as_unstructured_grid: ConverterDispatcher[\n    UnstructuredGrid\n] = ConverterDispatcher(UnstructuredGrid)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.load_polydata","title":"load_polydata  <code>module-attribute</code>","text":"<pre><code>load_polydata: ReaderDispatcher[PolyData] = (\n    ReaderDispatcher(PolyData)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.load_structured_grid","title":"load_structured_grid  <code>module-attribute</code>","text":"<pre><code>load_structured_grid: ReaderDispatcher[StructuredGrid] = (\n    ReaderDispatcher(StructuredGrid)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.load_unstructured_grid","title":"load_unstructured_grid  <code>module-attribute</code>","text":"<pre><code>load_unstructured_grid: ReaderDispatcher[\n    UnstructuredGrid\n] = ReaderDispatcher(UnstructuredGrid)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.as_mesh","title":"as_mesh","text":"<pre><code>as_mesh(mesh: Any) -&gt; PolyData | UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/_convert.py</code> <pre><code>def as_mesh(mesh: Any) -&gt; pv.PolyData | pv.UnstructuredGrid:\n    try:\n        return as_polydata(mesh)\n    except UnsupportedConverterError:\n        pass\n    return as_unstructured_grid(mesh)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.save_polydata","title":"save_polydata","text":"<pre><code>save_polydata(\n    path: Path, obj: PolyData, /, **kwargs\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/polydata/_write.py</code> <pre><code>@save.register(pv.PolyData, [\".ply\", \".stl\", \".vtp\"])\ndef save_polydata(path: Path, obj: pv.PolyData, /, **kwargs) -&gt; None:\n    obj.save(path, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.save_polydata_obj","title":"save_polydata_obj","text":"<pre><code>save_polydata_obj(\n    path: Path, obj: PolyData, /, **kwargs\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/polydata/_write.py</code> <pre><code>@save.register(pv.PolyData, [\".obj\"])\ndef save_polydata_obj(path: Path, obj: pv.PolyData, /, **kwargs) -&gt; None:\n    obj = obj.copy()\n    # `.obj` writer is buggy with materials\n    obj.point_data.active_texture_coordinates_name = None\n    if \"MaterialNames\" in obj.field_data:\n        del obj.field_data[\"MaterialNames\"]\n    obj.save(path, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.save_structured_grid","title":"save_structured_grid","text":"<pre><code>save_structured_grid(\n    path: Path, obj: StructuredGrid, /, **kwargs\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/structured_grid/_write.py</code> <pre><code>@save.register(pv.StructuredGrid, [\".vts\"])\ndef save_structured_grid(path: Path, obj: pv.StructuredGrid, /, **kwargs) -&gt; None:\n    obj.save(path, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/#liblaf.melon.io.pyvista.save_unstructured_grid","title":"save_unstructured_grid","text":"<pre><code>save_unstructured_grid(\n    path: Path, obj: UnstructuredGrid, /, **kwargs\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/_write.py</code> <pre><code>@save.register(pv.UnstructuredGrid, [\".vtu\"])\ndef save_unstructured_grid(path: Path, obj: pv.UnstructuredGrid, /, **kwargs) -&gt; None:\n    obj.save(path, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/pointset/","title":"pointset","text":""},{"location":"reference/liblaf/melon/io/pyvista/pointset/#liblaf.melon.io.pyvista.pointset","title":"liblaf.melon.io.pyvista.pointset","text":"<p>Attributes:</p> <ul> <li> <code>as_pointset</code>               (<code>ConverterDispatcher[PointSet]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/pyvista/pointset/#liblaf.melon.io.pyvista.pointset.as_pointset","title":"as_pointset  <code>module-attribute</code>","text":"<pre><code>as_pointset: ConverterDispatcher[PointSet] = (\n    ConverterDispatcher(PointSet)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/polydata/","title":"polydata","text":""},{"location":"reference/liblaf/melon/io/pyvista/polydata/#liblaf.melon.io.pyvista.polydata","title":"liblaf.melon.io.pyvista.polydata","text":"<p>Functions:</p> <ul> <li> <code>save_polydata</code>             \u2013              </li> <li> <code>save_polydata_obj</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>as_polydata</code>               (<code>ConverterDispatcher[PolyData]</code>)           \u2013            </li> <li> <code>load_polydata</code>               (<code>ReaderDispatcher[PolyData]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/pyvista/polydata/#liblaf.melon.io.pyvista.polydata.as_polydata","title":"as_polydata  <code>module-attribute</code>","text":"<pre><code>as_polydata: ConverterDispatcher[PolyData] = (\n    ConverterDispatcher(PolyData)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/polydata/#liblaf.melon.io.pyvista.polydata.load_polydata","title":"load_polydata  <code>module-attribute</code>","text":"<pre><code>load_polydata: ReaderDispatcher[PolyData] = (\n    ReaderDispatcher(PolyData)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/polydata/#liblaf.melon.io.pyvista.polydata.save_polydata","title":"save_polydata","text":"<pre><code>save_polydata(\n    path: Path, obj: PolyData, /, **kwargs\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/polydata/_write.py</code> <pre><code>@save.register(pv.PolyData, [\".ply\", \".stl\", \".vtp\"])\ndef save_polydata(path: Path, obj: pv.PolyData, /, **kwargs) -&gt; None:\n    obj.save(path, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/polydata/#liblaf.melon.io.pyvista.polydata.save_polydata_obj","title":"save_polydata_obj","text":"<pre><code>save_polydata_obj(\n    path: Path, obj: PolyData, /, **kwargs\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/polydata/_write.py</code> <pre><code>@save.register(pv.PolyData, [\".obj\"])\ndef save_polydata_obj(path: Path, obj: pv.PolyData, /, **kwargs) -&gt; None:\n    obj = obj.copy()\n    # `.obj` writer is buggy with materials\n    obj.point_data.active_texture_coordinates_name = None\n    if \"MaterialNames\" in obj.field_data:\n        del obj.field_data[\"MaterialNames\"]\n    obj.save(path, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/structured_grid/","title":"structured_grid","text":""},{"location":"reference/liblaf/melon/io/pyvista/structured_grid/#liblaf.melon.io.pyvista.structured_grid","title":"liblaf.melon.io.pyvista.structured_grid","text":"<p>Functions:</p> <ul> <li> <code>save_structured_grid</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>as_structured_grid</code>               (<code>ConverterDispatcher[StructuredGrid]</code>)           \u2013            </li> <li> <code>load_structured_grid</code>               (<code>ReaderDispatcher[StructuredGrid]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/pyvista/structured_grid/#liblaf.melon.io.pyvista.structured_grid.as_structured_grid","title":"as_structured_grid  <code>module-attribute</code>","text":"<pre><code>as_structured_grid: ConverterDispatcher[StructuredGrid] = (\n    ConverterDispatcher(StructuredGrid)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/structured_grid/#liblaf.melon.io.pyvista.structured_grid.load_structured_grid","title":"load_structured_grid  <code>module-attribute</code>","text":"<pre><code>load_structured_grid: ReaderDispatcher[StructuredGrid] = (\n    ReaderDispatcher(StructuredGrid)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/structured_grid/#liblaf.melon.io.pyvista.structured_grid.save_structured_grid","title":"save_structured_grid","text":"<pre><code>save_structured_grid(\n    path: Path, obj: StructuredGrid, /, **kwargs\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/structured_grid/_write.py</code> <pre><code>@save.register(pv.StructuredGrid, [\".vts\"])\ndef save_structured_grid(path: Path, obj: pv.StructuredGrid, /, **kwargs) -&gt; None:\n    obj.save(path, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/unstructured_grid/","title":"unstructured_grid","text":""},{"location":"reference/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid","title":"liblaf.melon.io.pyvista.unstructured_grid","text":"<p>Functions:</p> <ul> <li> <code>save_unstructured_grid</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>as_unstructured_grid</code>               (<code>ConverterDispatcher[UnstructuredGrid]</code>)           \u2013            </li> <li> <code>load_unstructured_grid</code>               (<code>ReaderDispatcher[UnstructuredGrid]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.as_unstructured_grid","title":"as_unstructured_grid  <code>module-attribute</code>","text":"<pre><code>as_unstructured_grid: ConverterDispatcher[\n    UnstructuredGrid\n] = ConverterDispatcher(UnstructuredGrid)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.load_unstructured_grid","title":"load_unstructured_grid  <code>module-attribute</code>","text":"<pre><code>load_unstructured_grid: ReaderDispatcher[\n    UnstructuredGrid\n] = ReaderDispatcher(UnstructuredGrid)\n</code></pre>"},{"location":"reference/liblaf/melon/io/pyvista/unstructured_grid/#liblaf.melon.io.pyvista.unstructured_grid.save_unstructured_grid","title":"save_unstructured_grid","text":"<pre><code>save_unstructured_grid(\n    path: Path, obj: UnstructuredGrid, /, **kwargs\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/pyvista/unstructured_grid/_write.py</code> <pre><code>@save.register(pv.UnstructuredGrid, [\".vtu\"])\ndef save_unstructured_grid(path: Path, obj: pv.UnstructuredGrid, /, **kwargs) -&gt; None:\n    obj.save(path, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/melon/io/trimesh/","title":"trimesh","text":""},{"location":"reference/liblaf/melon/io/trimesh/#liblaf.melon.io.trimesh","title":"liblaf.melon.io.trimesh","text":"<p>Functions:</p> <ul> <li> <code>save_trimesh</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>as_trimesh</code>               (<code>ConverterDispatcher[Trimesh]</code>)           \u2013            </li> <li> <code>load_trimesh</code>               (<code>ReaderDispatcher[Trimesh]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/io/trimesh/#liblaf.melon.io.trimesh.as_trimesh","title":"as_trimesh  <code>module-attribute</code>","text":"<pre><code>as_trimesh: ConverterDispatcher[Trimesh] = (\n    ConverterDispatcher(Trimesh)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/trimesh/#liblaf.melon.io.trimesh.load_trimesh","title":"load_trimesh  <code>module-attribute</code>","text":"<pre><code>load_trimesh: ReaderDispatcher[Trimesh] = ReaderDispatcher(\n    Trimesh\n)\n</code></pre>"},{"location":"reference/liblaf/melon/io/trimesh/#liblaf.melon.io.trimesh.save_trimesh","title":"save_trimesh","text":"<pre><code>save_trimesh(path: Path, obj: Trimesh, /, **kwargs) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/trimesh/_write.py</code> <pre><code>@save.register(tm.Trimesh, [\".obj\", \".off\", \".ply\", \".stl\"])\ndef save_trimesh(path: Path, obj: tm.Trimesh, /, **kwargs) -&gt; None:\n    obj.export(path, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/","title":"wrap","text":""},{"location":"reference/liblaf/melon/io/wrap/#liblaf.melon.io.wrap","title":"liblaf.melon.io.wrap","text":"<p>Modules:</p> <ul> <li> <code>landmarks</code>           \u2013            </li> <li> <code>polygons</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>get_landmarks_path</code>             \u2013              </li> <li> <code>get_polygons_path</code>             \u2013              </li> <li> <code>load_landmarks</code>             \u2013              </li> <li> <code>load_polygons</code>             \u2013              </li> <li> <code>save_landmarks</code>             \u2013              </li> <li> <code>save_polygons</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.get_landmarks_path","title":"get_landmarks_path","text":"<pre><code>get_landmarks_path(path: str | PathLike[str]) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_utils.py</code> <pre><code>def get_landmarks_path(path: str | os.PathLike[str]) -&gt; Path:\n    path: Path = Path(path)\n    if path.suffix != \".json\":\n        return path.with_suffix(\".landmarks.json\")\n    return path\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.get_polygons_path","title":"get_polygons_path","text":"<pre><code>get_polygons_path(path: str | PathLike[str]) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_utils.py</code> <pre><code>def get_polygons_path(path: str | os.PathLike[str]) -&gt; Path:\n    path: Path = Path(path)\n    if path.suffix != \".json\":\n        return path.with_suffix(\".polygons.json\")\n    return path\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.load_landmarks","title":"load_landmarks","text":"<pre><code>load_landmarks(\n    path: str | PathLike[str],\n) -&gt; Float[ndarray, \"N 3\"]\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_reader.py</code> <pre><code>def load_landmarks(path: str | os.PathLike[str]) -&gt; Float[np.ndarray, \"N 3\"]:\n    path: Path = get_landmarks_path(path)\n    if not path.exists():\n        return np.empty((0, 3), dtype=float)\n    data: list[dict[str, float]] = grapes.load(path)\n    return np.asarray([[p[\"x\"], p[\"y\"], p[\"z\"]] for p in data])\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.load_polygons","title":"load_polygons","text":"<pre><code>load_polygons(path: PathLike) -&gt; Integer[ndarray, ' N']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_reader.py</code> <pre><code>def load_polygons(path: PathLike) -&gt; Integer[np.ndarray, \" N\"]:\n    path: Path = get_polygons_path(path)\n    data: list[int] = grapes.load(path)\n    return np.asarray(data)\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.save_landmarks","title":"save_landmarks","text":"<pre><code>save_landmarks(\n    path: str | PathLike[str],\n    points: Float[ArrayLike, \"N 3\"],\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_writer.py</code> <pre><code>def save_landmarks(\n    path: str | os.PathLike[str], points: Float[ArrayLike, \"N 3\"]\n) -&gt; None:\n    path: Path = get_landmarks_path(path)\n    points: Float[np.ndarray, \"N 3\"] = np.asarray(points)\n    data: list[dict[str, float]] = [\n        {\"x\": p[0], \"y\": p[1], \"z\": p[2]} for p in points.tolist()\n    ]\n    grapes.save(path, data)\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/#liblaf.melon.io.wrap.save_polygons","title":"save_polygons","text":"<pre><code>save_polygons(\n    path: str | PathLike[str],\n    polygons: Integer[ArrayLike, \" N\"],\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_writer.py</code> <pre><code>def save_polygons(\n    path: str | os.PathLike[str], polygons: Integer[ArrayLike, \" N\"]\n) -&gt; None:\n    path: Path = get_polygons_path(path)\n    polygons = np.asarray(polygons)\n    grapes.save(path, polygons.tolist())\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/landmarks/","title":"landmarks","text":""},{"location":"reference/liblaf/melon/io/wrap/landmarks/#liblaf.melon.io.wrap.landmarks","title":"liblaf.melon.io.wrap.landmarks","text":"<p>Functions:</p> <ul> <li> <code>get_landmarks_path</code>             \u2013              </li> <li> <code>load_landmarks</code>             \u2013              </li> <li> <code>save_landmarks</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/io/wrap/landmarks/#liblaf.melon.io.wrap.landmarks.get_landmarks_path","title":"get_landmarks_path","text":"<pre><code>get_landmarks_path(path: str | PathLike[str]) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_utils.py</code> <pre><code>def get_landmarks_path(path: str | os.PathLike[str]) -&gt; Path:\n    path: Path = Path(path)\n    if path.suffix != \".json\":\n        return path.with_suffix(\".landmarks.json\")\n    return path\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/landmarks/#liblaf.melon.io.wrap.landmarks.load_landmarks","title":"load_landmarks","text":"<pre><code>load_landmarks(\n    path: str | PathLike[str],\n) -&gt; Float[ndarray, \"N 3\"]\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_reader.py</code> <pre><code>def load_landmarks(path: str | os.PathLike[str]) -&gt; Float[np.ndarray, \"N 3\"]:\n    path: Path = get_landmarks_path(path)\n    if not path.exists():\n        return np.empty((0, 3), dtype=float)\n    data: list[dict[str, float]] = grapes.load(path)\n    return np.asarray([[p[\"x\"], p[\"y\"], p[\"z\"]] for p in data])\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/landmarks/#liblaf.melon.io.wrap.landmarks.save_landmarks","title":"save_landmarks","text":"<pre><code>save_landmarks(\n    path: str | PathLike[str],\n    points: Float[ArrayLike, \"N 3\"],\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/landmarks/_writer.py</code> <pre><code>def save_landmarks(\n    path: str | os.PathLike[str], points: Float[ArrayLike, \"N 3\"]\n) -&gt; None:\n    path: Path = get_landmarks_path(path)\n    points: Float[np.ndarray, \"N 3\"] = np.asarray(points)\n    data: list[dict[str, float]] = [\n        {\"x\": p[0], \"y\": p[1], \"z\": p[2]} for p in points.tolist()\n    ]\n    grapes.save(path, data)\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/polygons/","title":"polygons","text":""},{"location":"reference/liblaf/melon/io/wrap/polygons/#liblaf.melon.io.wrap.polygons","title":"liblaf.melon.io.wrap.polygons","text":"<p>Functions:</p> <ul> <li> <code>get_polygons_path</code>             \u2013              </li> <li> <code>load_polygons</code>             \u2013              </li> <li> <code>save_polygons</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/io/wrap/polygons/#liblaf.melon.io.wrap.polygons.get_polygons_path","title":"get_polygons_path","text":"<pre><code>get_polygons_path(path: str | PathLike[str]) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_utils.py</code> <pre><code>def get_polygons_path(path: str | os.PathLike[str]) -&gt; Path:\n    path: Path = Path(path)\n    if path.suffix != \".json\":\n        return path.with_suffix(\".polygons.json\")\n    return path\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/polygons/#liblaf.melon.io.wrap.polygons.load_polygons","title":"load_polygons","text":"<pre><code>load_polygons(path: PathLike) -&gt; Integer[ndarray, ' N']\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_reader.py</code> <pre><code>def load_polygons(path: PathLike) -&gt; Integer[np.ndarray, \" N\"]:\n    path: Path = get_polygons_path(path)\n    data: list[int] = grapes.load(path)\n    return np.asarray(data)\n</code></pre>"},{"location":"reference/liblaf/melon/io/wrap/polygons/#liblaf.melon.io.wrap.polygons.save_polygons","title":"save_polygons","text":"<pre><code>save_polygons(\n    path: str | PathLike[str],\n    polygons: Integer[ArrayLike, \" N\"],\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/melon/io/wrap/polygons/_writer.py</code> <pre><code>def save_polygons(\n    path: str | os.PathLike[str], polygons: Integer[ArrayLike, \" N\"]\n) -&gt; None:\n    path: Path = get_polygons_path(path)\n    polygons = np.asarray(polygons)\n    grapes.save(path, polygons.tolist())\n</code></pre>"},{"location":"reference/liblaf/melon/mesh/","title":"mesh","text":""},{"location":"reference/liblaf/melon/mesh/#liblaf.melon.mesh","title":"liblaf.melon.mesh","text":"<p>Functions:</p> <ul> <li> <code>graph</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/mesh/#liblaf.melon.mesh.graph","title":"graph","text":"<pre><code>graph(mesh: Any) -&gt; Graph\n</code></pre> Source code in <code>src/liblaf/melon/mesh/_graph.py</code> <pre><code>def graph(mesh: Any) -&gt; nx.Graph:\n    mesh: pv.PolyData | pv.UnstructuredGrid = io.as_mesh(mesh).copy()\n    mesh.point_data[\"__point_id\"] = np.arange(mesh.n_points)\n    edges: pv.PolyData = mesh.extract_all_edges()  # pyright: ignore[reportAssignmentType]\n    edges = edges.compute_cell_sizes()  # pyright: ignore[reportAssignmentType]\n    point_id: Integer[np.ndarray, \" P\"] = edges.point_data[\"__point_id\"]\n    lines: Integer[np.ndarray, \"E 2\"] = edges.lines.reshape(edges.n_lines, 3)[:, 1:]\n    edgelist: pl.DataFrame = pl.from_dict(\n        {\n            \"source\": point_id[lines[:, 0]],\n            \"target\": point_id[lines[:, 1]],\n            \"length\": edges.cell_data[\"Length\"],\n        }  # pyright: ignore[reportArgumentType]\n    )\n    return nx.from_pandas_edgelist(edgelist, edge_attr=\"length\")\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/","title":"proximity","text":""},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity","title":"liblaf.melon.proximity","text":"<p>Classes:</p> <ul> <li> <code>NearestAlgorithm</code>           \u2013            </li> <li> <code>NearestAlgorithmPrepared</code>           \u2013            </li> <li> <code>NearestPoint</code>           \u2013            </li> <li> <code>NearestPointOnSurface</code>           \u2013            </li> <li> <code>NearestPointOnSurfacePrepared</code>           \u2013            </li> <li> <code>NearestPointOnSurfaceResult</code>           \u2013            </li> <li> <code>NearestPointPrepared</code>           \u2013            </li> <li> <code>NearestPointResult</code>           \u2013            </li> <li> <code>NearestResult</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>nearest</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestAlgorithm","title":"NearestAlgorithm","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestAlgorithm.prepare","title":"prepare  <code>abstractmethod</code>","text":"<pre><code>prepare(source: Any) -&gt; NearestAlgorithmPrepared\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_abc.py</code> <pre><code>@abc.abstractmethod\ndef prepare(self, source: Any) -&gt; NearestAlgorithmPrepared: ...\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestAlgorithmPrepared","title":"NearestAlgorithmPrepared","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestAlgorithmPrepared.query","title":"query  <code>abstractmethod</code>","text":"<pre><code>query(query: Any) -&gt; NearestResult\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_abc.py</code> <pre><code>@abc.abstractmethod\ndef query(self, query: Any) -&gt; NearestResult: ...\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPoint","title":"NearestPoint","text":"<p>               Bases: <code>NearestAlgorithm</code></p> <p>Parameters:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>, default:                   <code>32</code> )           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>, default:                   <code>-inf</code> )           \u2013            </li> <li> <code>workers</code>               (<code>int</code>, default:                   <code>-1</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPoint.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPoint.ignore_orientation","title":"ignore_orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_orientation: bool = True\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPoint.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPoint.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = field(\n    default=-inf, validator=le(1.0)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPoint.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPoint.prepare","title":"prepare","text":"<pre><code>prepare(source: Any) -&gt; NearestPointPrepared\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_nearest_point.py</code> <pre><code>@override\ndef prepare(self, source: Any) -&gt; NearestPointPrepared:\n    need_normals: bool = self.normal_threshold &gt; -1.0\n    source: pv.PointSet = io.as_pointset(source, point_normals=need_normals)\n    tree: scipy.spatial.KDTree = scipy.spatial.KDTree(source.points)\n    return NearestPointPrepared(\n        source=source,\n        tree=tree,\n        distance_threshold=self.distance_threshold,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        ignore_orientation=self.ignore_orientation,\n        workers=self.workers,\n    )\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurface","title":"NearestPointOnSurface","text":"<p>               Bases: <code>NearestAlgorithm</code></p> <p>Parameters:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>, default:                   <code>32</code> )           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>, default:                   <code>0.8</code> )           \u2013            </li> <li> <code>workers</code>               (<code>int</code>, default:                   <code>-1</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>prepare</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurface.distance_threshold","title":"distance_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float = 0.1\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurface.fallback_to_nearest_vertex","title":"fallback_to_nearest_vertex  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fallback_to_nearest_vertex: bool = True\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurface.ignore_orientation","title":"ignore_orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_orientation: bool = True\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurface.max_k","title":"max_k  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_k: int = 32\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurface.normal_threshold","title":"normal_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float = field(\n    default=0.8, validator=le(1.0)\n)\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurface.workers","title":"workers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workers: int = -1\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurface.prepare","title":"prepare","text":"<pre><code>prepare(source: Any) -&gt; NearestPointOnSurfacePrepared\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_nearest_point_on_surface.py</code> <pre><code>@override\ndef prepare(self, source: Any) -&gt; NearestPointOnSurfacePrepared:\n    source: tm.Trimesh = io.as_trimesh(source)\n    return NearestPointOnSurfacePrepared(\n        distance_threshold=self.distance_threshold,\n        fallback_to_nearest_vertex=self.fallback_to_nearest_vertex,\n        ignore_orientation=self.ignore_orientation,\n        max_k=self.max_k,\n        normal_threshold=self.normal_threshold,\n        workers=self.workers,\n        source=source,\n    )\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfacePrepared","title":"NearestPointOnSurfacePrepared","text":"<p>               Bases: <code>NearestAlgorithmPrepared</code></p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>Trimesh</code>)           \u2013            </li> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>fallback_to_nearest_vertex</code>               (<code>bool</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>source</code>               (<code>Trimesh</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfacePrepared.distance_threshold","title":"distance_threshold  <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfacePrepared.fallback_to_nearest_vertex","title":"fallback_to_nearest_vertex  <code>instance-attribute</code>","text":"<pre><code>fallback_to_nearest_vertex: bool\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfacePrepared.ignore_orientation","title":"ignore_orientation  <code>instance-attribute</code>","text":"<pre><code>ignore_orientation: bool\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfacePrepared.max_k","title":"max_k  <code>instance-attribute</code>","text":"<pre><code>max_k: int\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfacePrepared.normal_threshold","title":"normal_threshold  <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfacePrepared.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: Trimesh\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfacePrepared.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers: int\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfacePrepared.query","title":"query","text":"<pre><code>query(query: Any) -&gt; NearestPointOnSurfaceResult\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_nearest_point_on_surface.py</code> <pre><code>@override\ndef query(self, query: Any) -&gt; NearestPointOnSurfaceResult:\n    need_normals: bool = self.normal_threshold &gt; -1.0\n    query: pv.PointSet = io.as_pointset(query, point_normals=need_normals)\n    nearest: Float[np.ndarray, \"N 3\"]\n    distance: Float[np.ndarray, \" N\"]\n    triangle_id: Integer[np.ndarray, \" N\"]\n    nearest, distance, triangle_id = self.source.nearest.on_surface(query.points)\n    missing: Bool[np.ndarray, \" N\"] = (\n        distance &gt; self.distance_threshold * self.source.scale\n    )\n    if need_normals:\n        source_normals: Float[np.ndarray, \"N 3\"] = self.source.face_normals[\n            triangle_id\n        ]\n        target_normals: Float[np.ndarray, \"N 3\"] = query.point_data[\"Normals\"]\n        cosine_similarity: Float[np.ndarray, \" N\"] = np.vecdot(\n            source_normals, target_normals\n        )\n        if self.ignore_orientation:\n            cosine_similarity = np.abs(cosine_similarity)\n        missing |= cosine_similarity &lt; self.normal_threshold\n    distance[missing] = np.inf\n    nearest[missing] = np.nan\n    triangle_id[missing] = -1\n    result = NearestPointOnSurfaceResult(\n        distance=distance, missing=missing, nearest=nearest, triangle_id=triangle_id\n    )\n    if self.fallback_to_nearest_vertex:\n        result = self._fallback_to_nearest_vertex(query, result)\n    return result\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfaceResult","title":"NearestPointOnSurfaceResult","text":"<p>               Bases: <code>NearestResult</code></p> <p>Parameters:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, Q]</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, Q]</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> <li> <code>triangle_id</code>               (<code>Integer[ndarray, N]</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> <li> <code>triangle_id</code>               (<code>Integer[ndarray, ' N']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfaceResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfaceResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfaceResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, 'Q 3']\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointOnSurfaceResult.triangle_id","title":"triangle_id  <code>instance-attribute</code>","text":"<pre><code>triangle_id: Integer[ndarray, ' N']\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointPrepared","title":"NearestPointPrepared","text":"<p>               Bases: <code>NearestAlgorithmPrepared</code></p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>PointSet</code>)           \u2013            </li> <li> <code>tree</code>               (<code>KDTree</code>)           \u2013            </li> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>query</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>ignore_orientation</code>               (<code>bool</code>)           \u2013            </li> <li> <code>max_k</code>               (<code>int</code>)           \u2013            </li> <li> <code>normal_threshold</code>               (<code>float</code>)           \u2013            </li> <li> <code>source</code>               (<code>PointSet</code>)           \u2013            </li> <li> <code>tree</code>               (<code>KDTree</code>)           \u2013            </li> <li> <code>workers</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointPrepared.distance_threshold","title":"distance_threshold  <code>instance-attribute</code>","text":"<pre><code>distance_threshold: float\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointPrepared.ignore_orientation","title":"ignore_orientation  <code>instance-attribute</code>","text":"<pre><code>ignore_orientation: bool\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointPrepared.max_k","title":"max_k  <code>instance-attribute</code>","text":"<pre><code>max_k: int\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointPrepared.normal_threshold","title":"normal_threshold  <code>instance-attribute</code>","text":"<pre><code>normal_threshold: float\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointPrepared.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: PointSet\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointPrepared.tree","title":"tree  <code>instance-attribute</code>","text":"<pre><code>tree: KDTree\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointPrepared.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers: int\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointPrepared.query","title":"query","text":"<pre><code>query(query: Any) -&gt; NearestPointResult\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_nearest_point.py</code> <pre><code>@override\ndef query(self, query: Any) -&gt; NearestPointResult:\n    if self.normal_threshold &lt;= -1.0:\n        return self._nearest_vertex(query)\n    return self._nearest_vertex_with_normal_threshold(query)\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointResult","title":"NearestPointResult","text":"<p>               Bases: <code>NearestResult</code></p> <p>Parameters:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, Q]</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, Q]</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> <li> <code>vertex_id</code>               (<code>Integer[ndarray, N]</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> <li> <code>vertex_id</code>               (<code>Integer[ndarray, ' N']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, 'Q 3']\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestPointResult.vertex_id","title":"vertex_id  <code>instance-attribute</code>","text":"<pre><code>vertex_id: Integer[ndarray, ' N']\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestResult","title":"NearestResult","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parameters:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, Q]</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, Q]</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>distance</code>               (<code>Float[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>missing</code>               (<code>Bool[ndarray, ' Q']</code>)           \u2013            </li> <li> <code>nearest</code>               (<code>Float[ndarray, 'Q 3']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestResult.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: Float[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestResult.missing","title":"missing  <code>instance-attribute</code>","text":"<pre><code>missing: Bool[ndarray, ' Q']\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.NearestResult.nearest","title":"nearest  <code>instance-attribute</code>","text":"<pre><code>nearest: Float[ndarray, 'Q 3']\n</code></pre>"},{"location":"reference/liblaf/melon/proximity/#liblaf.melon.proximity.nearest","title":"nearest","text":"<pre><code>nearest(\n    source: Any,\n    query: Any,\n    algo: NearestPoint | None = None,\n) -&gt; NearestPointResult\n</code></pre><pre><code>nearest(\n    source: Any, query: Any, algo: NearestPointOnSurface\n) -&gt; NearestPointOnSurfaceResult\n</code></pre><pre><code>nearest(\n    source: Any, query: Any, algo: NearestAlgorithm\n) -&gt; NearestResult\n</code></pre> <pre><code>nearest(\n    source: Any,\n    query: Any,\n    algo: NearestAlgorithm | None = None,\n) -&gt; NearestResult\n</code></pre> Source code in <code>src/liblaf/melon/proximity/_nearest.py</code> <pre><code>def nearest(\n    source: Any, query: Any, algo: NearestAlgorithm | None = None\n) -&gt; NearestResult:\n    if algo is None:\n        algo = NearestPoint()\n    prepared: NearestAlgorithmPrepared = algo.prepare(source)\n    return prepared.query(query)\n</code></pre>"},{"location":"reference/liblaf/melon/tetra/","title":"tetra","text":""},{"location":"reference/liblaf/melon/tetra/#liblaf.melon.tetra","title":"liblaf.melon.tetra","text":"<p>Functions:</p> <ul> <li> <code>fix_winding</code>             \u2013              </li> <li> <code>flip</code>             \u2013              </li> <li> <code>transfer_point_data_from_surface</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/tetra/#liblaf.melon.tetra.fix_winding","title":"fix_winding","text":"<pre><code>fix_winding(mesh: Any) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/tetra/_flip.py</code> <pre><code>def fix_winding(mesh: Any) -&gt; pv.UnstructuredGrid:\n    mesh: pv.UnstructuredGrid = io.as_unstructured_grid(mesh)\n    mesh = mesh.compute_cell_sizes(length=False, area=False, volume=True)  # pyright: ignore[reportAssignmentType]\n    flip_mask: Bool[np.ndarray, \" C\"] = mesh.cell_data[\"Volume\"] &lt; 0\n    if np.any(flip_mask):\n        mesh = flip(mesh, flip_mask)\n        del mesh.cell_data[\"Volume\"]\n    return mesh\n</code></pre>"},{"location":"reference/liblaf/melon/tetra/#liblaf.melon.tetra.flip","title":"flip","text":"<pre><code>flip(\n    mesh: Any, mask: Bool[ArrayLike, \" C\"]\n) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/tetra/_flip.py</code> <pre><code>def flip(mesh: Any, mask: Bool[npt.ArrayLike, \" C\"]) -&gt; pv.UnstructuredGrid:\n    mesh: pv.UnstructuredGrid = io.as_unstructured_grid(mesh)\n    mask: Bool[np.ndarray, \" C\"] = np.asarray(mask)\n    tetras: Integer[np.ndarray, \"C 4\"] = mesh.cells_dict[pv.CellType.TETRA]  # pyright: ignore[reportArgumentType]\n    tetras[mask] = tetras[mask][:, [0, 3, 2, 1]]\n    result = pv.UnstructuredGrid({pv.CellType.TETRA: tetras}, mesh.points)\n    result.copy_attributes(mesh)\n    return result\n</code></pre>"},{"location":"reference/liblaf/melon/tetra/#liblaf.melon.tetra.transfer_point_data_from_surface","title":"transfer_point_data_from_surface","text":"<pre><code>transfer_point_data_from_surface(\n    src: Any,\n    dst: Any,\n    *,\n    data: str | Iterable[str] | None = None,\n    fill: Any | Mapping[str, Any] | None = None,\n    nearest: NearestPoint | None = None,\n) -&gt; UnstructuredGrid\n</code></pre> Source code in <code>src/liblaf/melon/tetra/_transfer.py</code> <pre><code>def transfer_point_data_from_surface(\n    src: Any,\n    dst: Any,\n    *,\n    data: str | Iterable[str] | None = None,\n    fill: Any | Mapping[str, Any] | None = None,\n    nearest: NearestPoint | None = None,\n) -&gt; pv.UnstructuredGrid:\n    src: pv.PolyData = io.as_polydata(src)\n    dst: pv.UnstructuredGrid = io.as_unstructured_grid(dst).copy()\n    dst.point_data[\"__point_id\"] = np.arange(dst.n_points)\n    data = src.point_data.keys() if data is None else grapes.as_iterable(data)\n    fill = _make_fill(fill)\n    surface: pv.PolyData = dst.extract_surface()  # pyright: ignore[reportAssignmentType]\n    surface = transfer_point_data(src, surface, data=data, fill=fill, nearest=nearest)\n    surface_point_id: Integer[np.ndarray, \" N\"] = surface.point_data[\"__point_id\"]\n    for name in data:\n        surface_data: np.ndarray = surface.point_data[name]\n        if name not in dst.point_data:\n            dst.point_data[name] = np.full(\n                (dst.n_points, *surface_data.shape[1:]), fill[name]\n            )\n        dst.point_data[name][surface_point_id] = surface_data\n    del dst.point_data[\"__point_id\"]\n    return dst\n</code></pre>"},{"location":"reference/liblaf/melon/tri/","title":"tri","text":""},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri","title":"liblaf.melon.tri","text":"<p>Functions:</p> <ul> <li> <code>compute_edge_lengths</code>             \u2013              </li> <li> <code>contains</code>             \u2013              </li> <li> <code>extract_cells</code>             \u2013              </li> <li> <code>extract_groups</code>             \u2013              </li> <li> <code>extract_points</code>             \u2013              </li> <li> <code>fast_wrapping</code>             \u2013              </li> <li> <code>group_selection_mask</code>             \u2013              </li> <li> <code>intersection</code>             \u2013              </li> <li> <code>is_volume</code>             \u2013              </li> <li> <code>merge_points</code>             \u2013              </li> <li> <code>select_groups</code>             \u2013              </li> <li> <code>transfer_cell_data_to_point</code>             \u2013              </li> <li> <code>transfer_point_data</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.compute_edge_lengths","title":"compute_edge_lengths","text":"<pre><code>compute_edge_lengths(mesh: Any) -&gt; Float[ndarray, ' E']\n</code></pre> Source code in <code>src/liblaf/melon/tri/_compute_edge_length.py</code> <pre><code>def compute_edge_lengths(mesh: Any) -&gt; Float[np.ndarray, \" E\"]:\n    mesh: pv.PolyData = io.as_polydata(mesh)\n    edges: pv.PolyData = mesh.extract_all_edges()  # pyright: ignore[reportAssignmentType]\n    edges = edges.compute_cell_sizes()  # pyright: ignore[reportAssignmentType]\n    return edges.cell_data[\"Length\"]\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.contains","title":"contains","text":"<pre><code>contains(mesh: Any, pcl: Any) -&gt; Bool[ndarray, ' N']\n</code></pre> Source code in <code>src/liblaf/melon/tri/_ray.py</code> <pre><code>def contains(mesh: Any, pcl: Any) -&gt; Bool[np.ndarray, \" N\"]:\n    mesh: tm.Trimesh = io.as_trimesh(mesh)\n    pcl: pv.PointSet = io.as_pointset(pcl)\n    return mesh.contains(pcl.points)\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.extract_cells","title":"extract_cells","text":"<pre><code>extract_cells(\n    mesh: Any,\n    ind: int | VectorLike[int],\n    *,\n    invert: bool = False,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/tri/_extract.py</code> <pre><code>def extract_cells(\n    mesh: Any, ind: int | VectorLike[int], *, invert: bool = False\n) -&gt; pv.PolyData:\n    mesh: pv.PolyData = io.as_polydata(mesh)\n    cells: pv.UnstructuredGrid = mesh.extract_cells(ind, invert=invert)  # pyright: ignore[reportAssignmentType]\n    surface: pv.PolyData = cells.extract_surface()  # pyright: ignore[reportAssignmentType]\n    return surface\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.extract_groups","title":"extract_groups","text":"<pre><code>extract_groups(\n    mesh: Any,\n    groups: int | str | Iterable[int | str],\n    *,\n    invert: bool = False,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/tri/_extract.py</code> <pre><code>def extract_groups(\n    mesh: Any, groups: int | str | Iterable[int | str], *, invert: bool = False\n) -&gt; pv.PolyData:\n    return extract_cells(mesh, select_groups(mesh, groups), invert=invert)\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.extract_points","title":"extract_points","text":"<pre><code>extract_points(\n    mesh: Any,\n    ind: int | VectorLike[int] | VectorLike[bool],\n    *,\n    adjacent_cells: bool = True,\n    include_cells: bool = True,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/tri/_extract.py</code> <pre><code>def extract_points(\n    mesh: Any,\n    ind: int | VectorLike[int] | VectorLike[bool],\n    *,\n    adjacent_cells: bool = True,\n    include_cells: bool = True,\n) -&gt; pv.PolyData:\n    mesh: pv.PolyData = io.as_polydata(mesh)\n    points: pv.UnstructuredGrid = mesh.extract_points(\n        ind, adjacent_cells=adjacent_cells, include_cells=include_cells\n    )  # pyright: ignore[reportAssignmentType]\n    surface: pv.PolyData = points.extract_surface()  # pyright: ignore[reportAssignmentType]\n    return surface\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.fast_wrapping","title":"fast_wrapping","text":"<pre><code>fast_wrapping(\n    source: Any,\n    target: Any,\n    *,\n    source_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    target_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    free_polygons_floating: Integer[ArrayLike, \" F\"]\n    | None = None,\n    verbose: bool = True,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/tri/_wrapping.py</code> <pre><code>def fast_wrapping(\n    source: Any,\n    target: Any,\n    *,\n    source_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    target_landmarks: Float[ArrayLike, \"L 3\"] | None = None,\n    free_polygons_floating: Integer[ArrayLike, \" F\"] | None = None,\n    verbose: bool = True,\n) -&gt; pv.PolyData:\n    from liblaf.melon.external import wrap\n\n    if source_landmarks is not None and target_landmarks is not None:\n        matrix: Float[np.ndarray, \"4 4\"]\n        transformed: Float[np.ndarray, \"L 3\"]\n        cost: float\n        matrix, transformed, cost = tm.registration.procrustes(\n            source_landmarks, target_landmarks\n        )\n        logger.debug(\"procrustes cost: {}\", cost)\n        source: pv.PolyData = io.as_polydata(source)\n        source = source.transform(matrix)  # pyright: ignore[reportAssignmentType]\n        source_landmarks = transformed\n    result: pv.PolyData = wrap.fast_wrapping(\n        source,\n        target,\n        source_landmarks=source_landmarks,\n        target_landmarks=target_landmarks,\n        free_polygons_floating=free_polygons_floating,\n        verbose=verbose,\n    )\n    return result\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.group_selection_mask","title":"group_selection_mask","text":"<pre><code>group_selection_mask(\n    mesh: PolyData, groups: int | str | Iterable[int | str]\n) -&gt; Bool[ndarray, \" C\"]\n</code></pre> Source code in <code>src/liblaf/melon/tri/_selection.py</code> <pre><code>def group_selection_mask(\n    mesh: pv.PolyData, groups: int | str | Iterable[int | str]\n) -&gt; Bool[np.ndarray, \" C\"]:\n    mesh: pv.PolyData = io.as_polydata(mesh)\n    group_ids: list[int] = as_group_ids(mesh, groups)\n    mask: Bool[np.ndarray, \" C\"] = np.isin(_get_group_id(mesh), group_ids)\n    return mask\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.intersection","title":"intersection","text":"<pre><code>intersection(\n    meshes: Sequence[Any],\n    *,\n    engine: Literal[\"blender\", \"manifold\"] | None = None,\n    check_volume: bool = True,\n    **kwargs,\n) -&gt; Trimesh\n</code></pre> Source code in <code>src/liblaf/melon/tri/_boolean.py</code> <pre><code>def intersection(\n    meshes: Sequence[Any],\n    *,\n    engine: Literal[\"blender\", \"manifold\"] | None = None,\n    check_volume: bool = True,\n    **kwargs,\n) -&gt; tm.Trimesh:\n    return tm.boolean.intersection(\n        meshes, engine=engine, check_volume=check_volume, **kwargs\n    )\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.is_volume","title":"is_volume","text":"<pre><code>is_volume(mesh: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/tri/_is_volume.py</code> <pre><code>def is_volume(mesh: Any) -&gt; bool:\n    mesh: tm.Trimesh = io.as_trimesh(mesh)\n    return mesh.is_volume\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.merge_points","title":"merge_points","text":"<pre><code>merge_points(mesh: Any, tolerance: float = 0.0) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/tri/_merge_points.py</code> <pre><code>def merge_points(mesh: Any, tolerance: float = 0.0) -&gt; pv.PolyData:\n    mesh: pv.PolyData = io.as_polydata(mesh)\n    result: pv.PolyData = cast(\"pv.PolyData\", mesh.merge_points(tolerance=tolerance))\n    result.field_data.update(mesh.field_data)\n    return result\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.select_groups","title":"select_groups","text":"<pre><code>select_groups(\n    mesh: Any, groups: int | str | Iterable[int | str]\n) -&gt; Integer[ndarray, \" N\"]\n</code></pre> Source code in <code>src/liblaf/melon/tri/_selection.py</code> <pre><code>def select_groups(\n    mesh: Any, groups: int | str | Iterable[int | str]\n) -&gt; Integer[np.ndarray, \" N\"]:\n    mesh: pv.PolyData = io.as_polydata(mesh)\n    group_ids: list[int] = as_group_ids(mesh, groups)\n    mask: Bool[np.ndarray, \" C\"] = np.isin(_get_group_id(mesh), group_ids)\n    indices: Integer[np.ndarray, \" N\"]\n    (indices,) = np.nonzero(mask)\n    return indices\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.transfer_cell_data_to_point","title":"transfer_cell_data_to_point","text":"<pre><code>transfer_cell_data_to_point(\n    src: Any,\n    dst: Any,\n    *,\n    data: str | Iterable[str] | None = None,\n    fill: Any | Mapping[str, Any] | None = None,\n    nearest: NearestPointOnSurface | None = None,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/tri/_transfer.py</code> <pre><code>def transfer_cell_data_to_point(\n    src: Any,\n    dst: Any,\n    *,\n    data: str | Iterable[str] | None = None,\n    fill: Any | Mapping[str, Any] | None = None,\n    nearest: NearestPointOnSurface | None = None,\n) -&gt; pv.PolyData:\n    src: pv.PolyData = io.as_polydata(src)\n    src = src.triangulate()  # pyright: ignore[reportAssignmentType]\n    dst: pv.PolyData = io.as_polydata(dst)\n    data = src.cell_data.keys() if data is None else grapes.as_iterable(data)\n    fill = fill if isinstance(fill, Mapping) else collections.defaultdict(lambda: fill)\n    nearest = NearestPointOnSurface() if nearest is None else nearest\n    prepared: NearestPointOnSurfacePrepared = nearest.prepare(src)\n    query: NearestPointOnSurfaceResult = prepared.query(dst.points)\n    missing: Bool[np.ndarray, \" N\"] = query[\"missing\"]\n    triangle_id: Integer[np.ndarray, \" N\"] = query[\"triangle_id\"]\n    for name, arr in src.cell_data.items():\n        dst.point_data[name] = arr[triangle_id]\n        if np.any(missing):\n            dst.point_data[name][missing] = fill[name]\n    return dst\n</code></pre>"},{"location":"reference/liblaf/melon/tri/#liblaf.melon.tri.transfer_point_data","title":"transfer_point_data","text":"<pre><code>transfer_point_data(\n    src: Any,\n    dst: Any,\n    *,\n    data: str | Iterable[str] | None = None,\n    fill: Any | Mapping[str, Any] | None = None,\n    nearest: NearestPoint | None = None,\n) -&gt; PolyData\n</code></pre> Source code in <code>src/liblaf/melon/tri/_transfer.py</code> <pre><code>def transfer_point_data(\n    src: Any,\n    dst: Any,\n    *,\n    data: str | Iterable[str] | None = None,\n    fill: Any | Mapping[str, Any] | None = None,\n    nearest: NearestPoint | None = None,\n) -&gt; pv.PolyData:\n    src: pv.PolyData = io.as_polydata(src)\n    dst: pv.PolyData = io.as_polydata(dst)\n    data = src.point_data.keys() if data is None else grapes.as_iterable(data)\n    fill = fill if isinstance(fill, Mapping) else collections.defaultdict(lambda: fill)\n    nearest = NearestPoint() if nearest is None else nearest\n    prepared: NearestPointPrepared = nearest.prepare(src)\n    query: NearestPointResult = prepared.query(dst)\n    missing: Bool[np.ndarray, \" N\"] = query[\"missing\"]\n    point_id: Integer[np.ndarray, \" N\"] = query[\"vertex_id\"]\n    for name in data:\n        dst.point_data[name] = src.point_data[name][point_id]\n        if np.any(missing):\n            dst.point_data[name][missing] = fill[name]\n    return dst\n</code></pre>"},{"location":"reference/liblaf/melon/typing/","title":"typing","text":""},{"location":"reference/liblaf/melon/typing/#liblaf.melon.typing","title":"liblaf.melon.typing","text":"<p>Type Aliases:</p> <ul> <li> <code>MeshLike</code>           \u2013            </li> <li> <code>PathLike</code>           \u2013            </li> <li> <code>PointSetLike</code>           \u2013            </li> <li> <code>PolyDataLike</code>           \u2013            </li> <li> <code>UnstructuredGridLike</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/melon/typing/#liblaf.melon.typing.MeshLike","title":"MeshLike","text":"<pre><code>MeshLike = Any\n</code></pre>"},{"location":"reference/liblaf/melon/typing/#liblaf.melon.typing.PathLike","title":"PathLike","text":"<pre><code>PathLike = str | PathLike[str]\n</code></pre>"},{"location":"reference/liblaf/melon/typing/#liblaf.melon.typing.PointSetLike","title":"PointSetLike","text":"<pre><code>PointSetLike = Any\n</code></pre>"},{"location":"reference/liblaf/melon/typing/#liblaf.melon.typing.PolyDataLike","title":"PolyDataLike","text":"<pre><code>PolyDataLike = Any\n</code></pre>"},{"location":"reference/liblaf/melon/typing/#liblaf.melon.typing.UnstructuredGridLike","title":"UnstructuredGridLike","text":"<pre><code>UnstructuredGridLike = Any\n</code></pre>"},{"location":"reference/liblaf/melon/utils/","title":"utils","text":""},{"location":"reference/liblaf/melon/utils/#liblaf.melon.utils","title":"liblaf.melon.utils","text":"<p>Functions:</p> <ul> <li> <code>is_array_like</code>             \u2013              </li> <li> <code>is_data_set</code>             \u2013              </li> <li> <code>is_image_data</code>             \u2013              </li> <li> <code>is_instance</code>             \u2013              </li> <li> <code>is_numpy</code>             \u2013              </li> <li> <code>is_point_set</code>             \u2013              </li> <li> <code>is_poly_data</code>             \u2013              </li> <li> <code>is_subclass</code>             \u2013              </li> <li> <code>is_trimesh</code>             \u2013              </li> <li> <code>is_unstructured_grid</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/melon/utils/#liblaf.melon.utils.is_array_like","title":"is_array_like","text":"<pre><code>is_array_like(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/utils/_typing.py</code> <pre><code>def is_array_like(obj: Any) -&gt; bool:\n    # TODO: Implement a more robust check for array-like objects.\n    return (\n        is_jax(obj)\n        or is_numpy(obj)\n        or is_torch(obj)\n        or is_warp(obj)\n        or isinstance(obj, Sequence)\n    )\n</code></pre>"},{"location":"reference/liblaf/melon/utils/#liblaf.melon.utils.is_data_set","title":"is_data_set","text":"<pre><code>is_data_set(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/utils/_typing.py</code> <pre><code>def is_data_set(obj: Any) -&gt; bool:\n    return is_instance(obj, \"pyvista\", \"DataSet\")\n</code></pre>"},{"location":"reference/liblaf/melon/utils/#liblaf.melon.utils.is_image_data","title":"is_image_data","text":"<pre><code>is_image_data(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/utils/_typing.py</code> <pre><code>def is_image_data(obj: Any) -&gt; bool:\n    return is_instance(obj, \"pyvista\", \"ImageData\")\n</code></pre>"},{"location":"reference/liblaf/melon/utils/#liblaf.melon.utils.is_instance","title":"is_instance","text":"<pre><code>is_instance(obj: Any, prefix: str, name: str) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/utils/_typing.py</code> <pre><code>def is_instance(obj: Any, prefix: str, name: str) -&gt; bool:\n    return is_subclass(type(obj), prefix, name)\n</code></pre>"},{"location":"reference/liblaf/melon/utils/#liblaf.melon.utils.is_numpy","title":"is_numpy","text":"<pre><code>is_numpy(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/utils/_typing.py</code> <pre><code>def is_numpy(obj: Any) -&gt; bool:\n    return is_instance(obj, \"numpy\", \"ndarray\")\n</code></pre>"},{"location":"reference/liblaf/melon/utils/#liblaf.melon.utils.is_point_set","title":"is_point_set","text":"<pre><code>is_point_set(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/utils/_typing.py</code> <pre><code>def is_point_set(obj: Any) -&gt; bool:\n    return is_instance(obj, \"pyvista\", \"PointSet\")\n</code></pre>"},{"location":"reference/liblaf/melon/utils/#liblaf.melon.utils.is_poly_data","title":"is_poly_data","text":"<pre><code>is_poly_data(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/utils/_typing.py</code> <pre><code>def is_poly_data(obj: Any) -&gt; bool:\n    return is_instance(obj, \"pyvista\", \"PolyData\")\n</code></pre>"},{"location":"reference/liblaf/melon/utils/#liblaf.melon.utils.is_subclass","title":"is_subclass","text":"<pre><code>is_subclass(cls: type, prefix: str, name: str) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/utils/_typing.py</code> <pre><code>def is_subclass(cls: type, prefix: str, name: str) -&gt; bool:\n    for base in inspect.getmro(cls):\n        if base.__module__.startswith(prefix) and base.__name__ == name:\n            return True\n    return False\n</code></pre>"},{"location":"reference/liblaf/melon/utils/#liblaf.melon.utils.is_trimesh","title":"is_trimesh","text":"<pre><code>is_trimesh(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/utils/_typing.py</code> <pre><code>def is_trimesh(obj: Any) -&gt; bool:\n    return is_instance(obj, \"trimesh\", \"Trimesh\")\n</code></pre>"},{"location":"reference/liblaf/melon/utils/#liblaf.melon.utils.is_unstructured_grid","title":"is_unstructured_grid","text":"<pre><code>is_unstructured_grid(obj: Any) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/melon/utils/_typing.py</code> <pre><code>def is_unstructured_grid(obj: Any) -&gt; bool:\n    return is_instance(obj, \"pyvista\", \"UnstructuredGrid\")\n</code></pre>"}]}